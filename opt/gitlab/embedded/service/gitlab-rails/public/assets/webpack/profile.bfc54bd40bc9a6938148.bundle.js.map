{"version":3,"sources":["webpack:///profile.bfc54bd40bc9a6938148.bundle.js","webpack:///./profile/profile_bundle.js","webpack:///./profile/gl_crop.js","webpack:////var/cache/omnibus/src/gitlab-rails/vendor/assets/javascripts/cropper.js","webpack:///./profile/profile.js"],"names":["webpackJsonp","RUZQ","module","exports","__webpack_require__","Yig8","__webpack_exports__","$","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_vendor_cropper__","_createClass","n","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","global","FILENAMEREGEX","GitLabCrop","input","_ref","arguments","undefined","filename","previewImage","modalCrop","pickImageEl","uploadImageBtn","modalCropImg","_ref$exportWidth","exportWidth","_ref$exportHeight","exportHeight","_ref$cropBoxWidth","cropBoxWidth","_ref$cropBoxHeight","cropBoxHeight","this","onUploadImageBtnClick","bind","onModalHide","onModalShow","onPickImageClick","fileInput","_","isString","attr","form","parents","getElement","cropActionsBtn","find","bindEvents","selector","_this","on","e","onFileInputChange","btn","onActionBtnClick","croppedImageBlob","trigger","cropper","viewMode","center","aspectRatio","modal","scalable","rotatable","zoomable","dragMode","guides","zoomOnTouch","zoomOnWheel","cropBoxMovable","cropBoxResizable","toggleDragModeOnDblclick","built","$image","container","width","height","left","top","preventDefault","setBlob","setPreview","val","data","result","method","option","readFile","reader","FileReader","onload","readAsDataURL","files","dataURL","array","binary","k","len","v","atob","split","push","charCodeAt","Blob","Uint8Array","type","replace","text","toDataURL","dataURLtoBlob","fn","glCrop","opts","each","window","gl","call","aX1M","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","apply","isNumber","isNaN","isUndefined","toArray","obj","offset","args","slice","proxy","context","concat","isCrossOriginURL","url","parts","match","location","protocol","hostname","port","addTimestamp","timestamp","Date","getTime","indexOf","getCrossOrigin","crossOrigin","getImageSize","image","callback","newImage","naturalWidth","IS_SAFARI","naturalHeight","document","createElement","src","getTransform","options","transforms","rotate","scaleX","scaleY","join","getRotatedSizes","isReversed","newWidth","newHeight","deg","abs","degree","arc","Math","PI","sinArc","sin","cosArc","cos","getSourceCanvas","translateX","translateY","rotated","canvas","getContext","dstX","dstY","dstWidth","dstHeight","advanced","canvasWidth","canvasHeight","save","translate","scale","drawImage","floor","restore","getTouchesCenter","touches","pageX","pageY","touch","getStringFromCharCode","dataView","start","str","fromCharCode","getUint8","getOrientation","arrayBuffer","orientation","exifIDCode","tiffOffset","firstIFDOffset","littleEndian","endianness","app1Start","ifdStart","DataView","byteLength","getUint16","getUint32","setUint16","dataURLToArrayBuffer","base64","REGEXP_DATA_URL_HEAD","ArrayBuffer","arrayBufferToDataURL","btoa","Cropper","element","$element","extend","DEFAULTS","isPlainObject","isLoaded","isBuilt","isCompleted","isRotated","isCropped","isDisabled","isReplaced","isLimited","wheeling","isImg","originalUrl","cropBox","init","$window","$document","navigator","NAMESPACE","CLASS_MODAL","CLASS_HIDE","CLASS_HIDDEN","CLASS_INVISIBLE","CLASS_MOVE","CLASS_CROP","CLASS_DISABLED","CLASS_BG","EVENT_MOUSE_DOWN","EVENT_MOUSE_MOVE","EVENT_MOUSE_UP","EVENT_WHEEL","EVENT_DBLCLICK","EVENT_LOAD","EVENT_ERROR","EVENT_RESIZE","EVENT_BUILD","EVENT_BUILT","EVENT_CROP_START","EVENT_CROP_MOVE","EVENT_CROP_END","EVENT_CROP","EVENT_ZOOM","REGEXP_ACTIONS","REGEXP_DATA_URL","REGEXP_DATA_URL_JPEG","DATA_PREVIEW","DATA_ACTION","ACTION_EAST","ACTION_WEST","ACTION_SOUTH","ACTION_NORTH","ACTION_SOUTH_EAST","ACTION_SOUTH_WEST","ACTION_NORTH_EAST","ACTION_NORTH_WEST","ACTION_ALL","ACTION_CROP","ACTION_MOVE","ACTION_ZOOM","ACTION_NONE","SUPPORT_CANVAS","isFunction","test","userAgent","vendor","num","Number","min","max","sqrt","round","String","constructor","$this","is","prop","load","Event","read","xhr","one","build","isDefaultPrevented","checkOrientation","clone","XMLHttpRequest","onerror","onabort","response","open","responseType","send","crossOriginUrl","$clone","checkCrossOrigin","complete","stop","addClass","insertAfter","off","remove","$cropper","$cropBox","$face","unbuild","$container","parent","TEMPLATE","$canvas","append","$dragBox","$viewBox","after","removeClass","initPreview","NaN","autoCrop","highlight","background","setDragMode","render","setData","setTimeout","initialImage","initialCanvas","initialCropBox","unbind","resetPreview","$preview","initContainer","initCanvas","initCropBox","renderCanvas","renderCropBox","css","minContainerWidth","minContainerHeight","containerWidth","containerHeight","imageNaturalWidth","imageNaturalHeight","is90Degree","oldLeft","oldTop","limitCanvas","isSizeLimited","isPositionLimited","minCanvasWidth","minCanvasHeight","newCanvasLeft","newCanvasTop","minWidth","minHeight","maxWidth","Infinity","maxHeight","minLeft","minTop","maxLeft","maxTop","isChanged","renderImage","limitCropBox","output","reversed","marginLeft","marginTop","transform","autoCropArea","minCropBoxWidth","minCropBoxHeight","maxCropBoxWidth","maxCropBoxHeight","movable","preview","getData","$clone2","html","removeData","originalWidth","originalHeight","ratio","cropstart","cropmove","cropend","crop","zoom","cropStart","wheel","dblclick","_cropMove","cropMove","_cropEnd","cropEnd","responsive","_resize","resize","canvasData","cropBoxData","getCanvasData","getCropBoxData","setCanvasData","setCropBoxData","hasClass","event","originalEvent","wheelZoomRatio","delta","deltaY","wheelDelta","detail","touchesLength","action","startX2","startY2","cropping","startX","startY","endX2","endY2","endX","endY","change","shiftKey","toggleClass","range","right","bottom","renderable","limited","x","y","X","Y","move","x1","y1","x2","y2","z1","z2","reset","clear","onlyColorChanged","add","enable","disable","destroy","offsetX","offsetY","moveTo","_event","zoomTo","oldRatio","rotateTo","isRounded","isScaled","getContainerData","getImageData","isWidthChanged","isHeightChanged","getCroppedCanvas","scaledWidth","scaledHeight","scaledRatio","fillColor","fillStyle","fillRect","srcWidth","srcHeight","source","sourceWidth","sourceHeight","params","srcX","srcY","setAspectRatio","mode","croppable","setDefaults","other","noConflict","dYvO","Profile","onSubmitForm","initAvatarGlCrop","cropOpts","avatarGlCrop","submitForm","beforeUpdateUsername","afterUpdateUsername","onUpdateNotifs","submit","saveForm","saved","Flash","self","formData","FormData","avatarBlob","getBlob","ajax","dataType","processData","contentType","success","message","error","jqXHR","responseJSON","scrollTo","$title","comment","utils","getPagePath"],"mappings":"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","file":"profile.bfc54bd40bc9a6938148.bundle.js","sourcesContent":["webpackJsonp([14,25,26],{\n\n/***/ \"RUZQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"Yig8\");\n__webpack_require__(\"dYvO\");\n\n/***/ }),\n\n/***/ \"Yig8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function($) {Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_cropper__ = __webpack_require__(\"aX1M\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_cropper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vendor_cropper__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable no-useless-escape, max-len, quotes, no-var, no-underscore-dangle, func-names, space-before-function-paren, no-unused-vars, no-return-assign, object-shorthand, one-var, one-var-declaration-per-line, comma-dangle, consistent-return, class-methods-use-this, new-parens */\n\n\n\n(function (global) {\n  // Matches everything but the file name\n  var FILENAMEREGEX = /^.*[\\\\\\/]/;\n\n  var GitLabCrop = function () {\n    function GitLabCrop(input) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          filename = _ref.filename,\n          previewImage = _ref.previewImage,\n          modalCrop = _ref.modalCrop,\n          pickImageEl = _ref.pickImageEl,\n          uploadImageBtn = _ref.uploadImageBtn,\n          modalCropImg = _ref.modalCropImg,\n          _ref$exportWidth = _ref.exportWidth,\n          exportWidth = _ref$exportWidth === undefined ? 200 : _ref$exportWidth,\n          _ref$exportHeight = _ref.exportHeight,\n          exportHeight = _ref$exportHeight === undefined ? 200 : _ref$exportHeight,\n          _ref$cropBoxWidth = _ref.cropBoxWidth,\n          cropBoxWidth = _ref$cropBoxWidth === undefined ? 200 : _ref$cropBoxWidth,\n          _ref$cropBoxHeight = _ref.cropBoxHeight,\n          cropBoxHeight = _ref$cropBoxHeight === undefined ? 200 : _ref$cropBoxHeight;\n\n      _classCallCheck(this, GitLabCrop);\n\n      this.onUploadImageBtnClick = this.onUploadImageBtnClick.bind(this);\n      this.onModalHide = this.onModalHide.bind(this);\n      this.onModalShow = this.onModalShow.bind(this);\n      this.onPickImageClick = this.onPickImageClick.bind(this);\n      this.fileInput = $(input);\n      this.modalCropImg = _.isString(this.modalCropImg) ? $(this.modalCropImg) : this.modalCropImg;\n      this.fileInput.attr('name', this.fileInput.attr('name') + '-trigger').attr('id', this.fileInput.attr('id') + '-trigger');\n      this.exportWidth = exportWidth;\n      this.exportHeight = exportHeight;\n      this.cropBoxWidth = cropBoxWidth;\n      this.cropBoxHeight = cropBoxHeight;\n      this.form = this.fileInput.parents('form');\n      this.filename = filename;\n      this.previewImage = previewImage;\n      this.modalCrop = modalCrop;\n      this.pickImageEl = pickImageEl;\n      this.uploadImageBtn = uploadImageBtn;\n      this.modalCropImg = modalCropImg;\n      this.filename = this.getElement(filename);\n      this.previewImage = this.getElement(previewImage);\n      this.pickImageEl = this.getElement(pickImageEl);\n      this.modalCrop = _.isString(modalCrop) ? $(modalCrop) : modalCrop;\n      this.uploadImageBtn = _.isString(uploadImageBtn) ? $(uploadImageBtn) : uploadImageBtn;\n      this.modalCropImg = _.isString(modalCropImg) ? $(modalCropImg) : modalCropImg;\n      this.cropActionsBtn = this.modalCrop.find('[data-method]');\n      this.bindEvents();\n    }\n\n    _createClass(GitLabCrop, [{\n      key: 'getElement',\n      value: function getElement(selector) {\n        return $(selector, this.form);\n      }\n    }, {\n      key: 'bindEvents',\n      value: function bindEvents() {\n        var _this;\n        _this = this;\n        this.fileInput.on('change', function (e) {\n          return _this.onFileInputChange(e, this);\n        });\n        this.pickImageEl.on('click', this.onPickImageClick);\n        this.modalCrop.on('shown.bs.modal', this.onModalShow);\n        this.modalCrop.on('hidden.bs.modal', this.onModalHide);\n        this.uploadImageBtn.on('click', this.onUploadImageBtnClick);\n        this.cropActionsBtn.on('click', function (e) {\n          var btn;\n          btn = this;\n          return _this.onActionBtnClick(btn);\n        });\n        return this.croppedImageBlob = null;\n      }\n    }, {\n      key: 'onPickImageClick',\n      value: function onPickImageClick() {\n        return this.fileInput.trigger('click');\n      }\n    }, {\n      key: 'onModalShow',\n      value: function onModalShow() {\n        var _this;\n        _this = this;\n        return this.modalCropImg.cropper({\n          viewMode: 1,\n          center: false,\n          aspectRatio: 1,\n          modal: true,\n          scalable: false,\n          rotatable: false,\n          zoomable: true,\n          dragMode: 'move',\n          guides: false,\n          zoomOnTouch: false,\n          zoomOnWheel: false,\n          cropBoxMovable: false,\n          cropBoxResizable: false,\n          toggleDragModeOnDblclick: false,\n          built: function built() {\n            var $image, container, cropBoxHeight, cropBoxWidth;\n            $image = $(this);\n            container = $image.cropper('getContainerData');\n            cropBoxWidth = _this.cropBoxWidth;\n            cropBoxHeight = _this.cropBoxHeight;\n            return $image.cropper('setCropBoxData', {\n              width: cropBoxWidth,\n              height: cropBoxHeight,\n              left: (container.width - cropBoxWidth) / 2,\n              top: (container.height - cropBoxHeight) / 2\n            });\n          }\n        });\n      }\n    }, {\n      key: 'onModalHide',\n      value: function onModalHide() {\n        return this.modalCropImg.attr('src', '').cropper('destroy');\n      }\n    }, {\n      key: 'onUploadImageBtnClick',\n      value: function onUploadImageBtnClick(e) {\n        e.preventDefault();\n        this.setBlob();\n        this.setPreview();\n        this.modalCrop.modal('hide');\n        return this.fileInput.val('');\n      }\n    }, {\n      key: 'onActionBtnClick',\n      value: function onActionBtnClick(btn) {\n        var data, result;\n        data = $(btn).data();\n        if (this.modalCropImg.data('cropper') && data.method) {\n          return result = this.modalCropImg.cropper(data.method, data.option);\n        }\n      }\n    }, {\n      key: 'onFileInputChange',\n      value: function onFileInputChange(e, input) {\n        return this.readFile(input);\n      }\n    }, {\n      key: 'readFile',\n      value: function readFile(input) {\n        var _this, reader;\n        _this = this;\n        reader = new FileReader();\n        reader.onload = function () {\n          _this.modalCropImg.attr('src', reader.result);\n          return _this.modalCrop.modal('show');\n        };\n        return reader.readAsDataURL(input.files[0]);\n      }\n    }, {\n      key: 'dataURLtoBlob',\n      value: function dataURLtoBlob(dataURL) {\n        var array, binary, i, k, len, v;\n        binary = atob(dataURL.split(',')[1]);\n        array = [];\n        for (k = i = 0, len = binary.length; i < len; k = i += 1) {\n          v = binary[k];\n          array.push(binary.charCodeAt(k));\n        }\n        return new Blob([new Uint8Array(array)], {\n          type: 'image/png'\n        });\n      }\n    }, {\n      key: 'setPreview',\n      value: function setPreview() {\n        var filename;\n        this.previewImage.attr('src', this.dataURL);\n        filename = this.fileInput.val().replace(FILENAMEREGEX, '');\n        return this.filename.text(filename);\n      }\n    }, {\n      key: 'setBlob',\n      value: function setBlob() {\n        this.dataURL = this.modalCropImg.cropper('getCroppedCanvas', {\n          width: 200,\n          height: 200\n        }).toDataURL('image/png');\n        return this.croppedImageBlob = this.dataURLtoBlob(this.dataURL);\n      }\n    }, {\n      key: 'getBlob',\n      value: function getBlob() {\n        return this.croppedImageBlob;\n      }\n    }]);\n\n    return GitLabCrop;\n  }();\n\n  $.fn.glCrop = function (opts) {\n    return this.each(function () {\n      return $(this).data('glcrop', new GitLabCrop(this, opts));\n    });\n  };\n})(window.gl || (window.gl = {}));\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(\"lwLq\")))\n\n/***/ }),\n\n/***/ \"aX1M\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Cropper v2.3.0\n * https://github.com/fengyuanchen/cropper\n *\n * Copyright (c) 2014-2016 Fengyuan Chen and contributors\n * Released under the MIT license\n *\n * Date: 2016-02-22T02:13:13.332Z\n */\n\n(function (factory) {\n  if (true) {\n    // AMD. Register as anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"lwLq\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports === 'object') {\n    // Node / CommonJS\n    factory(require('jquery'));\n  } else {\n    // Browser globals.\n    factory(jQuery);\n  }\n})(function ($) {\n\n  'use strict';\n\n  // Globals\n  var $window = $(window);\n  var $document = $(document);\n  var location = window.location;\n  var navigator = window.navigator;\n  var ArrayBuffer = window.ArrayBuffer;\n  var Uint8Array = window.Uint8Array;\n  var DataView = window.DataView;\n  var btoa = window.btoa;\n\n  // Constants\n  var NAMESPACE = 'cropper';\n\n  // Classes\n  var CLASS_MODAL = 'cropper-modal';\n  var CLASS_HIDE = 'cropper-hide';\n  var CLASS_HIDDEN = 'cropper-hidden';\n  var CLASS_INVISIBLE = 'cropper-invisible';\n  var CLASS_MOVE = 'cropper-move';\n  var CLASS_CROP = 'cropper-crop';\n  var CLASS_DISABLED = 'cropper-disabled';\n  var CLASS_BG = 'cropper-bg';\n\n  // Events\n  var EVENT_MOUSE_DOWN = 'mousedown touchstart pointerdown MSPointerDown';\n  var EVENT_MOUSE_MOVE = 'mousemove touchmove pointermove MSPointerMove';\n  var EVENT_MOUSE_UP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';\n  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_LOAD = 'load.' + NAMESPACE;\n  var EVENT_ERROR = 'error.' + NAMESPACE;\n  var EVENT_RESIZE = 'resize.' + NAMESPACE; // Bind to window with namespace\n  var EVENT_BUILD = 'build.' + NAMESPACE;\n  var EVENT_BUILT = 'built.' + NAMESPACE;\n  var EVENT_CROP_START = 'cropstart.' + NAMESPACE;\n  var EVENT_CROP_MOVE = 'cropmove.' + NAMESPACE;\n  var EVENT_CROP_END = 'cropend.' + NAMESPACE;\n  var EVENT_CROP = 'crop.' + NAMESPACE;\n  var EVENT_ZOOM = 'zoom.' + NAMESPACE;\n\n  // RegExps\n  var REGEXP_ACTIONS = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/;\n  var REGEXP_DATA_URL = /^data\\:/;\n  var REGEXP_DATA_URL_HEAD = /^data\\:([^\\;]+)\\;base64,/;\n  var REGEXP_DATA_URL_JPEG = /^data\\:image\\/jpeg.*;base64,/;\n\n  // Data keys\n  var DATA_PREVIEW = 'preview';\n  var DATA_ACTION = 'action';\n\n  // Actions\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_NONE = 'none';\n\n  // Supports\n  var SUPPORT_CANVAS = $.isFunction($('<canvas>')[0].getContext);\n  var IS_SAFARI = navigator && /safari/i.test(navigator.userAgent) && /apple computer/i.test(navigator.vendor);\n\n  // Maths\n  var num = Number;\n  var min = Math.min;\n  var max = Math.max;\n  var abs = Math.abs;\n  var sin = Math.sin;\n  var cos = Math.cos;\n  var sqrt = Math.sqrt;\n  var round = Math.round;\n  var floor = Math.floor;\n\n  // Utilities\n  var fromCharCode = String.fromCharCode;\n\n  function isNumber(n) {\n    return typeof n === 'number' && !isNaN(n);\n  }\n\n  function isUndefined(n) {\n    return typeof n === 'undefined';\n  }\n\n  function toArray(obj, offset) {\n    var args = [];\n\n    // This is necessary for IE8\n    if (isNumber(offset)) {\n      args.push(offset);\n    }\n\n    return args.slice.apply(obj, args);\n  }\n\n  // Custom proxy to avoid jQuery's guid\n  function proxy(fn, context) {\n    var args = toArray(arguments, 2);\n\n    return function () {\n      return fn.apply(context, args.concat(toArray(arguments)));\n    };\n  }\n\n  function isCrossOriginURL(url) {\n    var parts = url.match(/^(https?:)\\/\\/([^\\:\\/\\?#]+):?(\\d*)/i);\n\n    return parts && (\n      parts[1] !== location.protocol ||\n      parts[2] !== location.hostname ||\n      parts[3] !== location.port\n    );\n  }\n\n  function addTimestamp(url) {\n    var timestamp = 'timestamp=' + (new Date()).getTime();\n\n    return (url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp);\n  }\n\n  function getCrossOrigin(crossOrigin) {\n    return crossOrigin ? ' crossOrigin=\"' + crossOrigin + '\"' : '';\n  }\n\n  function getImageSize(image, callback) {\n    var newImage;\n\n    // Modern browsers (ignore Safari, #120 & #509)\n    if (image.naturalWidth && !IS_SAFARI) {\n      return callback(image.naturalWidth, image.naturalHeight);\n    }\n\n    // IE8: Don't use `new Image()` here (#319)\n    newImage = document.createElement('img');\n\n    newImage.onload = function () {\n      callback(this.width, this.height);\n    };\n\n    newImage.src = image.src;\n  }\n\n  function getTransform(options) {\n    var transforms = [];\n    var rotate = options.rotate;\n    var scaleX = options.scaleX;\n    var scaleY = options.scaleY;\n\n    if (isNumber(rotate)) {\n      transforms.push('rotate(' + rotate + 'deg)');\n    }\n\n    if (isNumber(scaleX) && isNumber(scaleY)) {\n      transforms.push('scale(' + scaleX + ',' + scaleY + ')');\n    }\n\n    return transforms.length ? transforms.join(' ') : 'none';\n  }\n\n  function getRotatedSizes(data, isReversed) {\n    var deg = abs(data.degree) % 180;\n    var arc = (deg > 90 ? (180 - deg) : deg) * Math.PI / 180;\n    var sinArc = sin(arc);\n    var cosArc = cos(arc);\n    var width = data.width;\n    var height = data.height;\n    var aspectRatio = data.aspectRatio;\n    var newWidth;\n    var newHeight;\n\n    if (!isReversed) {\n      newWidth = width * cosArc + height * sinArc;\n      newHeight = width * sinArc + height * cosArc;\n    } else {\n      newWidth = width / (cosArc + sinArc / aspectRatio);\n      newHeight = newWidth / aspectRatio;\n    }\n\n    return {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  function getSourceCanvas(image, data) {\n    var canvas = $('<canvas>')[0];\n    var context = canvas.getContext('2d');\n    var dstX = 0;\n    var dstY = 0;\n    var dstWidth = data.naturalWidth;\n    var dstHeight = data.naturalHeight;\n    var rotate = data.rotate;\n    var scaleX = data.scaleX;\n    var scaleY = data.scaleY;\n    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);\n    var rotatable = isNumber(rotate) && rotate !== 0;\n    var advanced = rotatable || scalable;\n    var canvasWidth = dstWidth * abs(scaleX || 1);\n    var canvasHeight = dstHeight * abs(scaleY || 1);\n    var translateX;\n    var translateY;\n    var rotated;\n\n    if (scalable) {\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    if (rotatable) {\n      rotated = getRotatedSizes({\n        width: canvasWidth,\n        height: canvasHeight,\n        degree: rotate\n      });\n\n      canvasWidth = rotated.width;\n      canvasHeight = rotated.height;\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    if (advanced) {\n      dstX = -dstWidth / 2;\n      dstY = -dstHeight / 2;\n\n      context.save();\n      context.translate(translateX, translateY);\n    }\n\n    if (rotatable) {\n      context.rotate(rotate * Math.PI / 180);\n    }\n\n    // Should call `scale` after rotated\n    if (scalable) {\n      context.scale(scaleX, scaleY);\n    }\n\n    context.drawImage(image, floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n\n    if (advanced) {\n      context.restore();\n    }\n\n    return canvas;\n  }\n\n  function getTouchesCenter(touches) {\n    var length = touches.length;\n    var pageX = 0;\n    var pageY = 0;\n\n    if (length) {\n      $.each(touches, function (i, touch) {\n        pageX += touch.pageX;\n        pageY += touch.pageY;\n      });\n\n      pageX /= length;\n      pageY /= length;\n    }\n\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    var i;\n\n    for (i = start, length += start; i < length; i++) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n\n    return str;\n  }\n\n  function getOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var length = dataView.byteLength;\n    var orientation;\n    var exifIDCode;\n    var tiffOffset;\n    var firstIFDOffset;\n    var littleEndian;\n    var endianness;\n    var app1Start;\n    var ifdStart;\n    var offset;\n    var i;\n\n    // Only handle JPEG image (start by 0xFFD8)\n    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n      offset = 2;\n\n      while (offset < length) {\n        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n          app1Start = offset;\n          break;\n        }\n\n        offset++;\n      }\n    }\n\n    if (app1Start) {\n      exifIDCode = app1Start + 4;\n      tiffOffset = app1Start + 10;\n\n      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n        endianness = dataView.getUint16(tiffOffset);\n        littleEndian = endianness === 0x4949;\n\n        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n      }\n    }\n\n    if (ifdStart) {\n      length = dataView.getUint16(ifdStart, littleEndian);\n\n      for (i = 0; i < length; i++) {\n        offset = ifdStart + i * 12 + 2;\n\n        if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {\n\n          // 8 is the offset of the current tag's value\n          offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(offset, littleEndian);\n\n          // Override the orientation with its default value for Safari (#120)\n          if (IS_SAFARI) {\n            dataView.setUint16(offset, 1, littleEndian);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return orientation;\n  }\n\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var length = binary.length;\n    var arrayBuffer = new ArrayBuffer(length);\n    var dataView = new Uint8Array(arrayBuffer);\n    var i;\n\n    for (i = 0; i < length; i++) {\n      dataView[i] = binary.charCodeAt(i);\n    }\n\n    return arrayBuffer;\n  }\n\n  // Only available for JPEG image\n  function arrayBufferToDataURL(arrayBuffer) {\n    var dataView = new Uint8Array(arrayBuffer);\n    var length = dataView.length;\n    var base64 = '';\n    var i;\n\n    for (i = 0; i < length; i++) {\n      base64 += fromCharCode(dataView[i]);\n    }\n\n    return 'data:image/jpeg;base64,' + btoa(base64);\n  }\n\n  function Cropper(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, Cropper.DEFAULTS, $.isPlainObject(options) && options);\n    this.isLoaded = false;\n    this.isBuilt = false;\n    this.isCompleted = false;\n    this.isRotated = false;\n    this.isCropped = false;\n    this.isDisabled = false;\n    this.isReplaced = false;\n    this.isLimited = false;\n    this.wheeling = false;\n    this.isImg = false;\n    this.originalUrl = '';\n    this.canvas = null;\n    this.cropBox = null;\n    this.init();\n  }\n\n  Cropper.prototype = {\n    constructor: Cropper,\n\n    init: function () {\n      var $this = this.$element;\n      var url;\n\n      if ($this.is('img')) {\n        this.isImg = true;\n\n        // Should use `$.fn.attr` here. e.g.: \"img/picture.jpg\"\n        this.originalUrl = url = $this.attr('src');\n\n        // Stop when it's a blank image\n        if (!url) {\n          return;\n        }\n\n        // Should use `$.fn.prop` here. e.g.: \"http://example.com/img/picture.jpg\"\n        url = $this.prop('src');\n      } else if ($this.is('canvas') && SUPPORT_CANVAS) {\n        url = $this[0].toDataURL();\n      }\n\n      this.load(url);\n    },\n\n    // A shortcut for triggering custom events\n    trigger: function (type, data) {\n      var e = $.Event(type, data);\n\n      this.$element.trigger(e);\n\n      return e;\n    },\n\n    load: function (url) {\n      var options = this.options;\n      var $this = this.$element;\n      var read;\n      var xhr;\n\n      if (!url) {\n        return;\n      }\n\n      // Trigger build event first\n      $this.one(EVENT_BUILD, options.build);\n\n      if (this.trigger(EVENT_BUILD).isDefaultPrevented()) {\n        return;\n      }\n\n      this.url = url;\n      this.image = {};\n\n      if (!options.checkOrientation || !ArrayBuffer) {\n        return this.clone();\n      }\n\n      read = $.proxy(this.read, this);\n\n      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari\n      if (REGEXP_DATA_URL.test(url)) {\n        return REGEXP_DATA_URL_JPEG.test(url) ?\n          read(dataURLToArrayBuffer(url)) :\n          this.clone();\n      }\n\n      xhr = new XMLHttpRequest();\n\n      xhr.onerror = xhr.onabort = $.proxy(function () {\n        this.clone();\n      }, this);\n\n      xhr.onload = function () {\n        read(this.response);\n      };\n\n      xhr.open('get', url);\n      xhr.responseType = 'arraybuffer';\n      xhr.send();\n    },\n\n    read: function (arrayBuffer) {\n      var options = this.options;\n      var orientation = getOrientation(arrayBuffer);\n      var image = this.image;\n      var rotate;\n      var scaleX;\n      var scaleY;\n\n      if (orientation > 1) {\n        this.url = arrayBufferToDataURL(arrayBuffer);\n\n        switch (orientation) {\n\n          // flip horizontal\n          case 2:\n            scaleX = -1;\n            break;\n\n          // rotate left 180°\n          case 3:\n            rotate = -180;\n            break;\n\n          // flip vertical\n          case 4:\n            scaleY = -1;\n            break;\n\n          // flip vertical + rotate right 90°\n          case 5:\n            rotate = 90;\n            scaleY = -1;\n            break;\n\n          // rotate right 90°\n          case 6:\n            rotate = 90;\n            break;\n\n          // flip horizontal + rotate right 90°\n          case 7:\n            rotate = 90;\n            scaleX = -1;\n            break;\n\n          // rotate left 90°\n          case 8:\n            rotate = -90;\n            break;\n        }\n      }\n\n      if (options.rotatable) {\n        image.rotate = rotate;\n      }\n\n      if (options.scalable) {\n        image.scaleX = scaleX;\n        image.scaleY = scaleY;\n      }\n\n      this.clone();\n    },\n\n    clone: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var url = this.url;\n      var crossOrigin = '';\n      var crossOriginUrl;\n      var $clone;\n\n      if (options.checkCrossOrigin && isCrossOriginURL(url)) {\n        crossOrigin = $this.prop('crossOrigin');\n\n        if (crossOrigin) {\n          crossOriginUrl = url;\n        } else {\n          crossOrigin = 'anonymous';\n\n          // Bust cache (#148) when there is not a \"crossOrigin\" property\n          crossOriginUrl = addTimestamp(url);\n        }\n      }\n\n      this.crossOrigin = crossOrigin;\n      this.crossOriginUrl = crossOriginUrl;\n      this.$clone = $clone = $('<img' + getCrossOrigin(crossOrigin) + ' src=\"' + (crossOriginUrl || url) + '\">');\n\n      if (this.isImg) {\n        if ($this[0].complete) {\n          this.start();\n        } else {\n          $this.one(EVENT_LOAD, $.proxy(this.start, this));\n        }\n      } else {\n        $clone.\n          one(EVENT_LOAD, $.proxy(this.start, this)).\n          one(EVENT_ERROR, $.proxy(this.stop, this)).\n          addClass(CLASS_HIDE).\n          insertAfter($this);\n      }\n    },\n\n    start: function () {\n      var $image = this.$element;\n      var $clone = this.$clone;\n\n      if (!this.isImg) {\n        $clone.off(EVENT_ERROR, this.stop);\n        $image = $clone;\n      }\n\n      getImageSize($image[0], $.proxy(function (naturalWidth, naturalHeight) {\n        $.extend(this.image, {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight,\n          aspectRatio: naturalWidth / naturalHeight\n        });\n\n        this.isLoaded = true;\n        this.build();\n      }, this));\n    },\n\n    stop: function () {\n      this.$clone.remove();\n      this.$clone = null;\n    },\n\n    build: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $clone = this.$clone;\n      var $cropper;\n      var $cropBox;\n      var $face;\n\n      if (!this.isLoaded) {\n        return;\n      }\n\n      // Unbuild first when replace\n      if (this.isBuilt) {\n        this.unbuild();\n      }\n\n      // Create cropper elements\n      this.$container = $this.parent();\n      this.$cropper = $cropper = $(Cropper.TEMPLATE);\n      this.$canvas = $cropper.find('.cropper-canvas').append($clone);\n      this.$dragBox = $cropper.find('.cropper-drag-box');\n      this.$cropBox = $cropBox = $cropper.find('.cropper-crop-box');\n      this.$viewBox = $cropper.find('.cropper-view-box');\n      this.$face = $face = $cropBox.find('.cropper-face');\n\n      // Hide the original image\n      $this.addClass(CLASS_HIDDEN).after($cropper);\n\n      // Show the clone image if is hidden\n      if (!this.isImg) {\n        $clone.removeClass(CLASS_HIDE);\n      }\n\n      this.initPreview();\n      this.bind();\n\n      options.aspectRatio = max(0, options.aspectRatio) || NaN;\n      options.viewMode = max(0, min(3, round(options.viewMode))) || 0;\n\n      if (options.autoCrop) {\n        this.isCropped = true;\n\n        if (options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      } else {\n        $cropBox.addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.guides) {\n        $cropBox.find('.cropper-dashed').addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.center) {\n        $cropBox.find('.cropper-center').addClass(CLASS_HIDDEN);\n      }\n\n      if (options.cropBoxMovable) {\n        $face.addClass(CLASS_MOVE).data(DATA_ACTION, ACTION_ALL);\n      }\n\n      if (!options.highlight) {\n        $face.addClass(CLASS_INVISIBLE);\n      }\n\n      if (options.background) {\n        $cropper.addClass(CLASS_BG);\n      }\n\n      if (!options.cropBoxResizable) {\n        $cropBox.find('.cropper-line, .cropper-point').addClass(CLASS_HIDDEN);\n      }\n\n      this.setDragMode(options.dragMode);\n      this.render();\n      this.isBuilt = true;\n      this.setData(options.data);\n      $this.one(EVENT_BUILT, options.built);\n\n      // Trigger the built event asynchronously to keep `data('cropper')` is defined\n      setTimeout($.proxy(function () {\n        this.trigger(EVENT_BUILT);\n        this.isCompleted = true;\n      }, this), 0);\n    },\n\n    unbuild: function () {\n      if (!this.isBuilt) {\n        return;\n      }\n\n      this.isBuilt = false;\n      this.isCompleted = false;\n      this.initialImage = null;\n\n      // Clear `initialCanvas` is necessary when replace\n      this.initialCanvas = null;\n      this.initialCropBox = null;\n      this.container = null;\n      this.canvas = null;\n\n      // Clear `cropBox` is necessary when replace\n      this.cropBox = null;\n      this.unbind();\n\n      this.resetPreview();\n      this.$preview = null;\n\n      this.$viewBox = null;\n      this.$cropBox = null;\n      this.$dragBox = null;\n      this.$canvas = null;\n      this.$container = null;\n\n      this.$cropper.remove();\n      this.$cropper = null;\n    },\n\n    render: function () {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    initContainer: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $container = this.$container;\n      var $cropper = this.$cropper;\n\n      $cropper.addClass(CLASS_HIDDEN);\n      $this.removeClass(CLASS_HIDDEN);\n\n      $cropper.css((this.container = {\n        width: max($container.width(), num(options.minContainerWidth) || 200),\n        height: max($container.height(), num(options.minContainerHeight) || 100)\n      }));\n\n      $this.addClass(CLASS_HIDDEN);\n      $cropper.removeClass(CLASS_HIDDEN);\n    },\n\n    // Canvas (image wrapper)\n    initCanvas: function () {\n      var viewMode = this.options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var image = this.image;\n      var imageNaturalWidth = image.naturalWidth;\n      var imageNaturalHeight = image.naturalHeight;\n      var is90Degree = abs(image.rotate) === 90;\n      var naturalWidth = is90Degree ? imageNaturalHeight : imageNaturalWidth;\n      var naturalHeight = is90Degree ? imageNaturalWidth : imageNaturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerWidth;\n      var canvasHeight = containerHeight;\n      var canvas;\n\n      if (containerHeight * aspectRatio > containerWidth) {\n        if (viewMode === 3) {\n          canvasWidth = containerHeight * aspectRatio;\n        } else {\n          canvasHeight = containerWidth / aspectRatio;\n        }\n      } else {\n        if (viewMode === 3) {\n          canvasHeight = containerWidth / aspectRatio;\n        } else {\n          canvasWidth = containerHeight * aspectRatio;\n        }\n      }\n\n      canvas = {\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        aspectRatio: aspectRatio,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n\n      canvas.oldLeft = canvas.left = (containerWidth - canvasWidth) / 2;\n      canvas.oldTop = canvas.top = (containerHeight - canvasHeight) / 2;\n\n      this.canvas = canvas;\n      this.isLimited = (viewMode === 1 || viewMode === 2);\n      this.limitCanvas(true, true);\n      this.initialImage = $.extend({}, image);\n      this.initialCanvas = $.extend({}, canvas);\n    },\n\n    limitCanvas: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var viewMode = options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n      var cropBox = this.cropBox;\n      var isCropped = this.isCropped && cropBox;\n      var minCanvasWidth;\n      var minCanvasHeight;\n      var newCanvasLeft;\n      var newCanvasTop;\n\n      if (isSizeLimited) {\n        minCanvasWidth = num(options.minCanvasWidth) || 0;\n        minCanvasHeight = num(options.minCanvasHeight) || 0;\n\n        if (viewMode) {\n          if (viewMode > 1) {\n            minCanvasWidth = max(minCanvasWidth, containerWidth);\n            minCanvasHeight = max(minCanvasHeight, containerHeight);\n\n            if (viewMode === 3) {\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          } else {\n            if (minCanvasWidth) {\n              minCanvasWidth = max(minCanvasWidth, isCropped ? cropBox.width : 0);\n            } else if (minCanvasHeight) {\n              minCanvasHeight = max(minCanvasHeight, isCropped ? cropBox.height : 0);\n            } else if (isCropped) {\n              minCanvasWidth = cropBox.width;\n              minCanvasHeight = cropBox.height;\n\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          }\n        }\n\n        if (minCanvasWidth && minCanvasHeight) {\n          if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n            minCanvasHeight = minCanvasWidth / aspectRatio;\n          } else {\n            minCanvasWidth = minCanvasHeight * aspectRatio;\n          }\n        } else if (minCanvasWidth) {\n          minCanvasHeight = minCanvasWidth / aspectRatio;\n        } else if (minCanvasHeight) {\n          minCanvasWidth = minCanvasHeight * aspectRatio;\n        }\n\n        canvas.minWidth = minCanvasWidth;\n        canvas.minHeight = minCanvasHeight;\n        canvas.maxWidth = Infinity;\n        canvas.maxHeight = Infinity;\n      }\n\n      if (isPositionLimited) {\n        if (viewMode) {\n          newCanvasLeft = containerWidth - canvas.width;\n          newCanvasTop = containerHeight - canvas.height;\n\n          canvas.minLeft = min(0, newCanvasLeft);\n          canvas.minTop = min(0, newCanvasTop);\n          canvas.maxLeft = max(0, newCanvasLeft);\n          canvas.maxTop = max(0, newCanvasTop);\n\n          if (isCropped && this.isLimited) {\n            canvas.minLeft = min(\n              cropBox.left,\n              cropBox.left + cropBox.width - canvas.width\n            );\n            canvas.minTop = min(\n              cropBox.top,\n              cropBox.top + cropBox.height - canvas.height\n            );\n            canvas.maxLeft = cropBox.left;\n            canvas.maxTop = cropBox.top;\n\n            if (viewMode === 2) {\n              if (canvas.width >= containerWidth) {\n                canvas.minLeft = min(0, newCanvasLeft);\n                canvas.maxLeft = max(0, newCanvasLeft);\n              }\n\n              if (canvas.height >= containerHeight) {\n                canvas.minTop = min(0, newCanvasTop);\n                canvas.maxTop = max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvas.minLeft = -canvas.width;\n          canvas.minTop = -canvas.height;\n          canvas.maxLeft = containerWidth;\n          canvas.maxTop = containerHeight;\n        }\n      }\n    },\n\n    renderCanvas: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var rotate = image.rotate;\n      var naturalWidth = image.naturalWidth;\n      var naturalHeight = image.naturalHeight;\n      var aspectRatio;\n      var rotated;\n\n      if (this.isRotated) {\n        this.isRotated = false;\n\n        // Computes rotated sizes with image sizes\n        rotated = getRotatedSizes({\n          width: image.width,\n          height: image.height,\n          degree: rotate\n        });\n\n        aspectRatio = rotated.width / rotated.height;\n\n        if (aspectRatio !== canvas.aspectRatio) {\n          canvas.left -= (rotated.width - canvas.width) / 2;\n          canvas.top -= (rotated.height - canvas.height) / 2;\n          canvas.width = rotated.width;\n          canvas.height = rotated.height;\n          canvas.aspectRatio = aspectRatio;\n          canvas.naturalWidth = naturalWidth;\n          canvas.naturalHeight = naturalHeight;\n\n          // Computes rotated sizes with natural image sizes\n          if (rotate % 180) {\n            rotated = getRotatedSizes({\n              width: naturalWidth,\n              height: naturalHeight,\n              degree: rotate\n            });\n\n            canvas.naturalWidth = rotated.width;\n            canvas.naturalHeight = rotated.height;\n          }\n\n          this.limitCanvas(true, false);\n        }\n      }\n\n      if (canvas.width > canvas.maxWidth || canvas.width < canvas.minWidth) {\n        canvas.left = canvas.oldLeft;\n      }\n\n      if (canvas.height > canvas.maxHeight || canvas.height < canvas.minHeight) {\n        canvas.top = canvas.oldTop;\n      }\n\n      canvas.width = min(max(canvas.width, canvas.minWidth), canvas.maxWidth);\n      canvas.height = min(max(canvas.height, canvas.minHeight), canvas.maxHeight);\n\n      this.limitCanvas(false, true);\n\n      canvas.oldLeft = canvas.left = min(max(canvas.left, canvas.minLeft), canvas.maxLeft);\n      canvas.oldTop = canvas.top = min(max(canvas.top, canvas.minTop), canvas.maxTop);\n\n      this.$canvas.css({\n        width: canvas.width,\n        height: canvas.height,\n        left: canvas.left,\n        top: canvas.top\n      });\n\n      this.renderImage();\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCropBox(true, true);\n      }\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    renderImage: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var reversed;\n\n      if (image.rotate) {\n        reversed = getRotatedSizes({\n          width: canvas.width,\n          height: canvas.height,\n          degree: image.rotate,\n          aspectRatio: image.aspectRatio\n        }, true);\n      }\n\n      $.extend(image, reversed ? {\n        width: reversed.width,\n        height: reversed.height,\n        left: (canvas.width - reversed.width) / 2,\n        top: (canvas.height - reversed.height) / 2\n      } : {\n        width: canvas.width,\n        height: canvas.height,\n        left: 0,\n        top: 0\n      });\n\n      this.$clone.css({\n        width: image.width,\n        height: image.height,\n        marginLeft: image.left,\n        marginTop: image.top,\n        transform: getTransform(image)\n      });\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    initCropBox: function () {\n      var options = this.options;\n      var canvas = this.canvas;\n      var aspectRatio = options.aspectRatio;\n      var autoCropArea = num(options.autoCropArea) || 0.8;\n      var cropBox = {\n            width: canvas.width,\n            height: canvas.height\n          };\n\n      if (aspectRatio) {\n        if (canvas.height * aspectRatio > canvas.width) {\n          cropBox.height = cropBox.width / aspectRatio;\n        } else {\n          cropBox.width = cropBox.height * aspectRatio;\n        }\n      }\n\n      this.cropBox = cropBox;\n      this.limitCropBox(true, true);\n\n      // Initialize auto crop area\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      // The width of auto crop area must large than \"minWidth\", and the height too. (#164)\n      cropBox.width = max(cropBox.minWidth, cropBox.width * autoCropArea);\n      cropBox.height = max(cropBox.minHeight, cropBox.height * autoCropArea);\n      cropBox.oldLeft = cropBox.left = canvas.left + (canvas.width - cropBox.width) / 2;\n      cropBox.oldTop = cropBox.top = canvas.top + (canvas.height - cropBox.height) / 2;\n\n      this.initialCropBox = $.extend({}, cropBox);\n    },\n\n    limitCropBox: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var isLimited = this.isLimited;\n      var minCropBoxWidth;\n      var minCropBoxHeight;\n      var maxCropBoxWidth;\n      var maxCropBoxHeight;\n\n      if (isSizeLimited) {\n        minCropBoxWidth = num(options.minCropBoxWidth) || 0;\n        minCropBoxHeight = num(options.minCropBoxHeight) || 0;\n\n        // The min/maxCropBoxWidth/Height must be less than containerWidth/Height\n        minCropBoxWidth = min(minCropBoxWidth, containerWidth);\n        minCropBoxHeight = min(minCropBoxHeight, containerHeight);\n        maxCropBoxWidth = min(containerWidth, isLimited ? canvas.width : containerWidth);\n        maxCropBoxHeight = min(containerHeight, isLimited ? canvas.height : containerHeight);\n\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        }\n\n        // The minWidth/Height must be less than maxWidth/Height\n        cropBox.minWidth = min(minCropBoxWidth, maxCropBoxWidth);\n        cropBox.minHeight = min(minCropBoxHeight, maxCropBoxHeight);\n        cropBox.maxWidth = maxCropBoxWidth;\n        cropBox.maxHeight = maxCropBoxHeight;\n      }\n\n      if (isPositionLimited) {\n        if (isLimited) {\n          cropBox.minLeft = max(0, canvas.left);\n          cropBox.minTop = max(0, canvas.top);\n          cropBox.maxLeft = min(containerWidth, canvas.left + canvas.width) - cropBox.width;\n          cropBox.maxTop = min(containerHeight, canvas.top + canvas.height) - cropBox.height;\n        } else {\n          cropBox.minLeft = 0;\n          cropBox.minTop = 0;\n          cropBox.maxLeft = containerWidth - cropBox.width;\n          cropBox.maxTop = containerHeight - cropBox.height;\n        }\n      }\n    },\n\n    renderCropBox: function () {\n      var options = this.options;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var cropBox = this.cropBox;\n\n      if (cropBox.width > cropBox.maxWidth || cropBox.width < cropBox.minWidth) {\n        cropBox.left = cropBox.oldLeft;\n      }\n\n      if (cropBox.height > cropBox.maxHeight || cropBox.height < cropBox.minHeight) {\n        cropBox.top = cropBox.oldTop;\n      }\n\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      this.limitCropBox(false, true);\n\n      cropBox.oldLeft = cropBox.left = min(max(cropBox.left, cropBox.minLeft), cropBox.maxLeft);\n      cropBox.oldTop = cropBox.top = min(max(cropBox.top, cropBox.minTop), cropBox.maxTop);\n\n      if (options.movable && options.cropBoxMovable) {\n\n        // Turn to move the canvas when the crop box is equal to the container\n        this.$face.data(DATA_ACTION, (cropBox.width === containerWidth && cropBox.height === containerHeight) ? ACTION_MOVE : ACTION_ALL);\n      }\n\n      this.$cropBox.css({\n        width: cropBox.width,\n        height: cropBox.height,\n        left: cropBox.left,\n        top: cropBox.top\n      });\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCanvas(true, true);\n      }\n\n      if (!this.isDisabled) {\n        this.output();\n      }\n    },\n\n    output: function () {\n      this.preview();\n\n      if (this.isCompleted) {\n        this.trigger(EVENT_CROP, this.getData());\n      } else if (!this.isBuilt) {\n\n        // Only trigger one crop event before complete\n        this.$element.one(EVENT_BUILT, $.proxy(function () {\n          this.trigger(EVENT_CROP, this.getData());\n        }, this));\n      }\n    },\n\n    initPreview: function () {\n      var crossOrigin = getCrossOrigin(this.crossOrigin);\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var $clone2;\n\n      this.$preview = $(this.options.preview);\n      this.$clone2 = $clone2 = $('<img' + crossOrigin + ' src=\"' + url + '\">');\n      this.$viewBox.html($clone2);\n      this.$preview.each(function () {\n        var $this = $(this);\n\n        // Save the original size for recover\n        $this.data(DATA_PREVIEW, {\n          width: $this.width(),\n          height: $this.height(),\n          html: $this.html()\n        });\n\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * (Occur only when margin-top <= -height)\n         */\n        $this.html(\n          '<img' + crossOrigin + ' src=\"' + url + '\" style=\"' +\n          'display:block;width:100%;height:auto;' +\n          'min-width:0!important;min-height:0!important;' +\n          'max-width:none!important;max-height:none!important;' +\n          'image-orientation:0deg!important;\">'\n        );\n      });\n    },\n\n    resetPreview: function () {\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n\n        $this.css({\n          width: data.width,\n          height: data.height\n        }).html(data.html).removeData(DATA_PREVIEW);\n      });\n    },\n\n    preview: function () {\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var cropBoxWidth = cropBox.width;\n      var cropBoxHeight = cropBox.height;\n      var width = image.width;\n      var height = image.height;\n      var left = cropBox.left - canvas.left - image.left;\n      var top = cropBox.top - canvas.top - image.top;\n\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      this.$clone2.css({\n        width: width,\n        height: height,\n        marginLeft: -left,\n        marginTop: -top,\n        transform: getTransform(image)\n      });\n\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n\n        $this.css({\n          width: newWidth,\n          height: newHeight\n        }).find('img').css({\n          width: width * ratio,\n          height: height * ratio,\n          marginLeft: -left * ratio,\n          marginTop: -top * ratio,\n          transform: getTransform(image)\n        });\n      });\n    },\n\n    bind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.on(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.on(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.on(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.on(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.on(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.on(EVENT_MOUSE_DOWN, $.proxy(this.cropStart, this));\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.on(EVENT_WHEEL, $.proxy(this.wheel, this));\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.on(EVENT_DBLCLICK, $.proxy(this.dblclick, this));\n      }\n\n      $document.\n        on(EVENT_MOUSE_MOVE, (this._cropMove = proxy(this.cropMove, this))).\n        on(EVENT_MOUSE_UP, (this._cropEnd = proxy(this.cropEnd, this)));\n\n      if (options.responsive) {\n        $window.on(EVENT_RESIZE, (this._resize = proxy(this.resize, this)));\n      }\n    },\n\n    unbind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.off(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.off(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.off(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.off(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.off(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.off(EVENT_MOUSE_DOWN, this.cropStart);\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.off(EVENT_WHEEL, this.wheel);\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.off(EVENT_DBLCLICK, this.dblclick);\n      }\n\n      $document.\n        off(EVENT_MOUSE_MOVE, this._cropMove).\n        off(EVENT_MOUSE_UP, this._cropEnd);\n\n      if (options.responsive) {\n        $window.off(EVENT_RESIZE, this._resize);\n      }\n    },\n\n    resize: function () {\n      var restore = this.options.restore;\n      var $container = this.$container;\n      var container = this.container;\n      var canvasData;\n      var cropBoxData;\n      var ratio;\n\n      // Check `container` is necessary for IE8\n      if (this.isDisabled || !container) {\n        return;\n      }\n\n      ratio = $container.width() / container.width;\n\n      // Resize when width changed or height changed\n      if (ratio !== 1 || $container.height() !== container.height) {\n        if (restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n\n        this.render();\n\n        if (restore) {\n          this.setCanvasData($.each(canvasData, function (i, n) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData($.each(cropBoxData, function (i, n) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n\n    dblclick: function () {\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (this.$dragBox.hasClass(CLASS_CROP)) {\n        this.setDragMode(ACTION_MOVE);\n      } else {\n        this.setDragMode(ACTION_CROP);\n      }\n    },\n\n    wheel: function (event) {\n      var e = event.originalEvent || event;\n      var ratio = num(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      event.preventDefault();\n\n      // Limit wheel speed to prevent zoom too fast\n      if (this.wheeling) {\n        return;\n      }\n\n      this.wheeling = true;\n\n      setTimeout($.proxy(function () {\n        this.wheeling = false;\n      }, this), 50);\n\n      if (e.deltaY) {\n        delta = e.deltaY > 0 ? 1 : -1;\n      } else if (e.wheelDelta) {\n        delta = -e.wheelDelta / 120;\n      } else if (e.detail) {\n        delta = e.detail > 0 ? 1 : -1;\n      }\n\n      this.zoom(-delta * ratio, event);\n    },\n\n    cropStart: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var touchesLength;\n      var action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.startX2 = e.pageX;\n            this.startY2 = e.pageY;\n            action = ACTION_ZOOM;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      action = action || $(e.target).data(DATA_ACTION);\n\n      if (REGEXP_ACTIONS.test(action)) {\n        if (this.trigger(EVENT_CROP_START, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.action = action;\n        this.cropping = false;\n\n        // IE8  has `event.pageX/Y`, but not `event.originalEvent.pageX/Y`\n        // IE10 has `event.originalEvent.pageX/Y`, but not `event.pageX/Y`\n        this.startX = e.pageX || originalEvent && originalEvent.pageX;\n        this.startY = e.pageY || originalEvent && originalEvent.pageY;\n\n        if (action === ACTION_CROP) {\n          this.cropping = true;\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      }\n    },\n\n    cropMove: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var action = this.action;\n      var touchesLength;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.endX2 = e.pageX;\n            this.endY2 = e.pageY;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      if (action) {\n        if (this.trigger(EVENT_CROP_MOVE, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.endX = e.pageX || originalEvent && originalEvent.pageX;\n        this.endY = e.pageY || originalEvent && originalEvent.pageY;\n\n        this.change(e.shiftKey, action === ACTION_ZOOM ? event : null);\n      }\n    },\n\n    cropEnd: function (event) {\n      var originalEvent = event.originalEvent;\n      var action = this.action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (action) {\n        event.preventDefault();\n\n        if (this.cropping) {\n          this.cropping = false;\n          this.$dragBox.toggleClass(CLASS_MODAL, this.isCropped && this.options.modal);\n        }\n\n        this.action = '';\n\n        this.trigger(EVENT_CROP_END, {\n          originalEvent: originalEvent,\n          action: action\n        });\n      }\n    },\n\n    change: function (shiftKey, event) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var action = this.action;\n      var container = this.container;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var width = cropBox.width;\n      var height = cropBox.height;\n      var left = cropBox.left;\n      var top = cropBox.top;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = container.width;\n      var maxHeight = container.height;\n      var renderable = true;\n      var offset;\n      var range;\n\n      // Locking aspect ratio in \"free mode\" by holding shift key (#259)\n      if (!aspectRatio && shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n\n      if (this.limited) {\n        minLeft = cropBox.minLeft;\n        minTop = cropBox.minTop;\n        maxWidth = minLeft + min(container.width, canvas.left + canvas.width);\n        maxHeight = minTop + min(container.height, canvas.top + canvas.height);\n      }\n\n      range = {\n        x: this.endX - this.startX,\n        y: this.endY - this.startY\n      };\n\n      if (aspectRatio) {\n        range.X = range.y * aspectRatio;\n        range.Y = range.x / aspectRatio;\n      }\n\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n\n        // Resize crop box\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top -= range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height -= range.y;\n          top += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width -= range.x;\n          left += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left -= range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += range.X;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        // Move canvas\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n\n        // Zoom canvas\n        case ACTION_ZOOM:\n          this.zoom((function (x1, y1, x2, y2) {\n            var z1 = sqrt(x1 * x1 + y1 * y1);\n            var z2 = sqrt(x2 * x2 + y2 * y2);\n\n            return (z2 - z1) / z1;\n          })(\n            abs(this.startX - this.startX2),\n            abs(this.startY - this.startY2),\n            abs(this.endX - this.endX2),\n            abs(this.endY - this.endY2)\n          ), event);\n          this.startX2 = this.endX2;\n          this.startY2 = this.endY2;\n          renderable = false;\n          break;\n\n        // Create crop box\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n\n          offset = this.$cropper.offset();\n          left = this.startX - offset.left;\n          top = this.startY - offset.top;\n          width = cropBox.minWidth;\n          height = cropBox.minHeight;\n\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n\n          if (range.y < 0) {\n            top -= height;\n          }\n\n          // Show the crop box if is hidden\n          if (!this.isCropped) {\n            this.$cropBox.removeClass(CLASS_HIDDEN);\n            this.isCropped = true;\n\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n\n          break;\n\n        // No default\n      }\n\n      if (renderable) {\n        cropBox.width = width;\n        cropBox.height = height;\n        cropBox.left = left;\n        cropBox.top = top;\n        this.action = action;\n\n        this.renderCropBox();\n      }\n\n      // Override\n      this.startX = this.endX;\n      this.startY = this.endY;\n    },\n\n    // Show the crop box manually\n    crop: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      if (!this.isCropped) {\n        this.isCropped = true;\n        this.limitCropBox(true, true);\n\n        if (this.options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n\n        this.$cropBox.removeClass(CLASS_HIDDEN);\n      }\n\n      this.setCropBoxData(this.initialCropBox);\n    },\n\n    // Reset the image and crop box to their initial states\n    reset: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      this.image = $.extend({}, this.initialImage);\n      this.canvas = $.extend({}, this.initialCanvas);\n      this.cropBox = $.extend({}, this.initialCropBox);\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    // Clear the crop box\n    clear: function () {\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      $.extend(this.cropBox, {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      });\n\n      this.isCropped = false;\n      this.renderCropBox();\n\n      this.limitCanvas(true, true);\n\n      // Render canvas after crop box rendered\n      this.renderCanvas();\n\n      this.$dragBox.removeClass(CLASS_MODAL);\n      this.$cropBox.addClass(CLASS_HIDDEN);\n    },\n\n    /**\n     * Replace the image's src and rebuild the cropper\n     *\n     * @param {String} url\n     * @param {Boolean} onlyColorChanged (optional)\n     */\n    replace: function (url, onlyColorChanged) {\n      if (!this.isDisabled && url) {\n        if (this.isImg) {\n          this.$element.attr('src', url);\n        }\n\n        if (onlyColorChanged) {\n          this.url = url;\n          this.$clone.attr('src', url);\n\n          if (this.isBuilt) {\n            this.$preview.find('img').add(this.$clone2).attr('src', url);\n          }\n        } else {\n          if (this.isImg) {\n            this.isReplaced = true;\n          }\n\n          // Clear previous data\n          this.options.data = null;\n          this.load(url);\n        }\n      }\n    },\n\n    // Enable (unfreeze) the cropper\n    enable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = false;\n        this.$cropper.removeClass(CLASS_DISABLED);\n      }\n    },\n\n    // Disable (freeze) the cropper\n    disable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = true;\n        this.$cropper.addClass(CLASS_DISABLED);\n      }\n    },\n\n    // Destroy the cropper and remove the instance from the image\n    destroy: function () {\n      var $this = this.$element;\n\n      if (this.isLoaded) {\n        if (this.isImg && this.isReplaced) {\n          $this.attr('src', this.originalUrl);\n        }\n\n        this.unbuild();\n        $this.removeClass(CLASS_HIDDEN);\n      } else {\n        if (this.isImg) {\n          $this.off(EVENT_LOAD, this.start);\n        } else if (this.$clone) {\n          this.$clone.remove();\n        }\n      }\n\n      $this.removeData(NAMESPACE);\n    },\n\n    /**\n     * Move the canvas with relative offsets\n     *\n     * @param {Number} offsetX\n     * @param {Number} offsetY (optional)\n     */\n    move: function (offsetX, offsetY) {\n      var canvas = this.canvas;\n\n      this.moveTo(\n        isUndefined(offsetX) ? offsetX : canvas.left + num(offsetX),\n        isUndefined(offsetY) ? offsetY : canvas.top + num(offsetY)\n      );\n    },\n\n    /**\n     * Move the canvas to an absolute point\n     *\n     * @param {Number} x\n     * @param {Number} y (optional)\n     */\n    moveTo: function (x, y) {\n      var canvas = this.canvas;\n      var isChanged = false;\n\n      // If \"y\" is not present, its default value is \"x\"\n      if (isUndefined(y)) {\n        y = x;\n      }\n\n      x = num(x);\n      y = num(y);\n\n      if (this.isBuilt && !this.isDisabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvas.left = x;\n          isChanged = true;\n        }\n\n        if (isNumber(y)) {\n          canvas.top = y;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderCanvas(true);\n        }\n      }\n    },\n\n    /**\n     * Zoom the canvas with a relative ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoom: function (ratio, _event) {\n      var canvas = this.canvas;\n\n      ratio = num(ratio);\n\n      if (ratio < 0) {\n        ratio =  1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n\n      this.zoomTo(canvas.width * ratio / canvas.naturalWidth, _event);\n    },\n\n    /**\n     * Zoom the canvas to an absolute ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoomTo: function (ratio, _event) {\n      var options = this.options;\n      var canvas = this.canvas;\n      var width = canvas.width;\n      var height = canvas.height;\n      var naturalWidth = canvas.naturalWidth;\n      var naturalHeight = canvas.naturalHeight;\n      var originalEvent;\n      var newWidth;\n      var newHeight;\n      var offset;\n      var center;\n\n      ratio = num(ratio);\n\n      if (ratio >= 0 && this.isBuilt && !this.isDisabled && options.zoomable) {\n        newWidth = naturalWidth * ratio;\n        newHeight = naturalHeight * ratio;\n\n        if (_event) {\n          originalEvent = _event.originalEvent;\n        }\n\n        if (this.trigger(EVENT_ZOOM, {\n          originalEvent: originalEvent,\n          oldRatio: width / naturalWidth,\n          ratio: newWidth / naturalWidth\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        if (originalEvent) {\n          offset = this.$cropper.offset();\n          center = originalEvent.touches ? getTouchesCenter(originalEvent.touches) : {\n            pageX: _event.pageX || originalEvent.pageX || 0,\n            pageY: _event.pageY || originalEvent.pageY || 0\n          };\n\n          // Zoom from the triggering point of the event\n          canvas.left -= (newWidth - width) * (\n            ((center.pageX - offset.left) - canvas.left) / width\n          );\n          canvas.top -= (newHeight - height) * (\n            ((center.pageY - offset.top) - canvas.top) / height\n          );\n        } else {\n\n          // Zoom from the center of the canvas\n          canvas.left -= (newWidth - width) / 2;\n          canvas.top -= (newHeight - height) / 2;\n        }\n\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Rotate the canvas with a relative degree\n     *\n     * @param {Number} degree\n     */\n    rotate: function (degree) {\n      this.rotateTo((this.image.rotate || 0) + num(degree));\n    },\n\n    /**\n     * Rotate the canvas to an absolute degree\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()\n     *\n     * @param {Number} degree\n     */\n    rotateTo: function (degree) {\n      degree = num(degree);\n\n      if (isNumber(degree) && this.isBuilt && !this.isDisabled && this.options.rotatable) {\n        this.image.rotate = degree % 360;\n        this.isRotated = true;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Scale the image\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()\n     *\n     * @param {Number} scaleX\n     * @param {Number} scaleY (optional)\n     */\n    scale: function (scaleX, scaleY) {\n      var image = this.image;\n      var isChanged = false;\n\n      // If \"scaleY\" is not present, its default value is \"scaleX\"\n      if (isUndefined(scaleY)) {\n        scaleY = scaleX;\n      }\n\n      scaleX = num(scaleX);\n      scaleY = num(scaleY);\n\n      if (this.isBuilt && !this.isDisabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          image.scaleX = scaleX;\n          isChanged = true;\n        }\n\n        if (isNumber(scaleY)) {\n          image.scaleY = scaleY;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderImage(true);\n        }\n      }\n    },\n\n    /**\n     * Scale the abscissa of the image\n     *\n     * @param {Number} scaleX\n     */\n    scaleX: function (scaleX) {\n      var scaleY = this.image.scaleY;\n\n      this.scale(scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n\n    /**\n     * Scale the ordinate of the image\n     *\n     * @param {Number} scaleY\n     */\n    scaleY: function (scaleY) {\n      var scaleX = this.image.scaleX;\n\n      this.scale(isNumber(scaleX) ? scaleX : 1, scaleY);\n    },\n\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     *\n     * @param {Boolean} isRounded (optional)\n     * @return {Object} data\n     */\n    getData: function (isRounded) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var ratio;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          x: cropBox.left - canvas.left,\n          y: cropBox.top - canvas.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n\n        ratio = image.width / image.naturalWidth;\n\n        $.each(data, function (i, n) {\n          n = n / ratio;\n          data[i] = isRounded ? round(n) : n;\n        });\n\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (options.rotatable) {\n        data.rotate = image.rotate || 0;\n      }\n\n      if (options.scalable) {\n        data.scaleX = image.scaleX || 1;\n        data.scaleY = image.scaleY || 1;\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the cropped area position and size with new data\n     *\n     * @param {Object} data\n     */\n    setData: function (data) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBoxData = {};\n      var isRotated;\n      var isScaled;\n      var ratio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== image.rotate) {\n            image.rotate = data.rotate;\n            this.isRotated = isRotated = true;\n          }\n        }\n\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== image.scaleX) {\n            image.scaleX = data.scaleX;\n            isScaled = true;\n          }\n\n          if (isNumber(data.scaleY) && data.scaleY !== image.scaleY) {\n            image.scaleY = data.scaleY;\n            isScaled = true;\n          }\n        }\n\n        if (isRotated) {\n          this.renderCanvas();\n        } else if (isScaled) {\n          this.renderImage();\n        }\n\n        ratio = image.width / image.naturalWidth;\n\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvas.left;\n        }\n\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvas.top;\n        }\n\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n\n        this.setCropBoxData(cropBoxData);\n      }\n    },\n\n    /**\n     * Get the container size data\n     *\n     * @return {Object} data\n     */\n    getContainerData: function () {\n      return this.isBuilt ? this.container : {};\n    },\n\n    /**\n     * Get the image position and size data\n     *\n     * @return {Object} data\n     */\n    getImageData: function () {\n      return this.isLoaded ? this.image : {};\n    },\n\n    /**\n     * Get the canvas position and size data\n     *\n     * @return {Object} data\n     */\n    getCanvasData: function () {\n      var canvas = this.canvas;\n      var data = {};\n\n      if (this.isBuilt) {\n        $.each([\n          'left',\n          'top',\n          'width',\n          'height',\n          'naturalWidth',\n          'naturalHeight'\n        ], function (i, n) {\n          data[n] = canvas[n];\n        });\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the canvas position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCanvasData: function (data) {\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvas.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          canvas.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          canvas.width = data.width;\n          canvas.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvas.height = data.height;\n          canvas.width = data.height * aspectRatio;\n        }\n\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Get the crop box position and size data\n     *\n     * @return {Object} data\n     */\n    getCropBoxData: function () {\n      var cropBox = this.cropBox;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          left: cropBox.left,\n          top: cropBox.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n      }\n\n      return data || {};\n    },\n\n    /**\n     * Set the crop box position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCropBoxData: function (data) {\n      var cropBox = this.cropBox;\n      var aspectRatio = this.options.aspectRatio;\n      var isWidthChanged;\n      var isHeightChanged;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && this.isCropped && !this.isDisabled && $.isPlainObject(data)) {\n\n        if (isNumber(data.left)) {\n          cropBox.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          cropBox.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          isWidthChanged = true;\n          cropBox.width = data.width;\n        }\n\n        if (isNumber(data.height)) {\n          isHeightChanged = true;\n          cropBox.height = data.height;\n        }\n\n        if (aspectRatio) {\n          if (isWidthChanged) {\n            cropBox.height = cropBox.width / aspectRatio;\n          } else if (isHeightChanged) {\n            cropBox.width = cropBox.height * aspectRatio;\n          }\n        }\n\n        this.renderCropBox();\n      }\n    },\n\n    /**\n     * Get a canvas drawn the cropped image\n     *\n     * @param {Object} options (optional)\n     * @return {HTMLCanvasElement} canvas\n     */\n    getCroppedCanvas: function (options) {\n      var originalWidth;\n      var originalHeight;\n      var canvasWidth;\n      var canvasHeight;\n      var scaledWidth;\n      var scaledHeight;\n      var scaledRatio;\n      var aspectRatio;\n      var canvas;\n      var context;\n      var data;\n\n      if (!this.isBuilt || !this.isCropped || !SUPPORT_CANVAS) {\n        return;\n      }\n\n      if (!$.isPlainObject(options)) {\n        options = {};\n      }\n\n      data = this.getData();\n      originalWidth = data.width;\n      originalHeight = data.height;\n      aspectRatio = originalWidth / originalHeight;\n\n      if ($.isPlainObject(options)) {\n        scaledWidth = options.width;\n        scaledHeight = options.height;\n\n        if (scaledWidth) {\n          scaledHeight = scaledWidth / aspectRatio;\n          scaledRatio = scaledWidth / originalWidth;\n        } else if (scaledHeight) {\n          scaledWidth = scaledHeight * aspectRatio;\n          scaledRatio = scaledHeight / originalHeight;\n        }\n      }\n\n      // The canvas element will use `Math.floor` on a float number, so floor first\n      canvasWidth = floor(scaledWidth || originalWidth);\n      canvasHeight = floor(scaledHeight || originalHeight);\n\n      canvas = $('<canvas>')[0];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      context = canvas.getContext('2d');\n\n      if (options.fillColor) {\n        context.fillStyle = options.fillColor;\n        context.fillRect(0, 0, canvasWidth, canvasHeight);\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n      context.drawImage.apply(context, (function () {\n        var source = getSourceCanvas(this.$clone[0], this.image);\n        var sourceWidth = source.width;\n        var sourceHeight = source.height;\n        var canvas = this.canvas;\n        var params = [source];\n\n        // Source canvas\n        var srcX = data.x + canvas.naturalWidth * (abs(data.scaleX || 1) - 1) / 2;\n        var srcY = data.y + canvas.naturalHeight * (abs(data.scaleY || 1) - 1) / 2;\n        var srcWidth;\n        var srcHeight;\n\n        // Destination canvas\n        var dstX;\n        var dstY;\n        var dstWidth;\n        var dstHeight;\n\n        if (srcX <= -originalWidth || srcX > sourceWidth) {\n          srcX = srcWidth = dstX = dstWidth = 0;\n        } else if (srcX <= 0) {\n          dstX = -srcX;\n          srcX = 0;\n          srcWidth = dstWidth = min(sourceWidth, originalWidth + srcX);\n        } else if (srcX <= sourceWidth) {\n          dstX = 0;\n          srcWidth = dstWidth = min(originalWidth, sourceWidth - srcX);\n        }\n\n        if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {\n          srcY = srcHeight = dstY = dstHeight = 0;\n        } else if (srcY <= 0) {\n          dstY = -srcY;\n          srcY = 0;\n          srcHeight = dstHeight = min(sourceHeight, originalHeight + srcY);\n        } else if (srcY <= sourceHeight) {\n          dstY = 0;\n          srcHeight = dstHeight = min(originalHeight, sourceHeight - srcY);\n        }\n\n        // All the numerical parameters should be integer for `drawImage` (#476)\n        params.push(floor(srcX), floor(srcY), floor(srcWidth), floor(srcHeight));\n\n        // Scale destination sizes\n        if (scaledRatio) {\n          dstX *= scaledRatio;\n          dstY *= scaledRatio;\n          dstWidth *= scaledRatio;\n          dstHeight *= scaledRatio;\n        }\n\n        // Avoid \"IndexSizeError\" in IE and Firefox\n        if (dstWidth > 0 && dstHeight > 0) {\n          params.push(floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n        }\n\n        return params;\n      }).call(this));\n\n      return canvas;\n    },\n\n    /**\n     * Change the aspect ratio of the crop box\n     *\n     * @param {Number} aspectRatio\n     */\n    setAspectRatio: function (aspectRatio) {\n      var options = this.options;\n\n      if (!this.isDisabled && !isUndefined(aspectRatio)) {\n\n        // 0 -> NaN\n        options.aspectRatio = max(0, aspectRatio) || NaN;\n\n        if (this.isBuilt) {\n          this.initCropBox();\n\n          if (this.isCropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n    },\n\n    /**\n     * Change the drag mode\n     *\n     * @param {String} mode (optional)\n     */\n    setDragMode: function (mode) {\n      var options = this.options;\n      var croppable;\n      var movable;\n\n      if (this.isLoaded && !this.isDisabled) {\n        croppable = mode === ACTION_CROP;\n        movable = options.movable && mode === ACTION_MOVE;\n        mode = (croppable || movable) ? mode : ACTION_NONE;\n\n        this.$dragBox.\n          data(DATA_ACTION, mode).\n          toggleClass(CLASS_CROP, croppable).\n          toggleClass(CLASS_MOVE, movable);\n\n        if (!options.cropBoxMovable) {\n\n          // Sync drag mode to crop box when it is not movable(#300)\n          this.$face.\n            data(DATA_ACTION, mode).\n            toggleClass(CLASS_CROP, croppable).\n            toggleClass(CLASS_MOVE, movable);\n        }\n      }\n    }\n  };\n\n  Cropper.DEFAULTS = {\n\n    // Define the view mode of the cropper\n    viewMode: 0, // 0, 1, 2, 3\n\n    // Define the dragging mode of the cropper\n    dragMode: 'crop', // 'crop', 'move' or 'none'\n\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n\n    // An object with the previous cropping result data\n    data: null,\n\n    // A jQuery selector for adding extra containers to preview\n    preview: '',\n\n    // Re-render the cropper when resize the window\n    responsive: true,\n\n    // Restore the cropped area after resize the window\n    restore: true,\n\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n\n    // Show the black modal\n    modal: true,\n\n    // Show the dashed lines for guiding\n    guides: true,\n\n    // Show the center indicator for guiding\n    center: true,\n\n    // Show the white modal to highlight the crop box\n    highlight: true,\n\n    // Show the grid background\n    background: true,\n\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n\n    // Enable to move the image\n    movable: true,\n\n    // Enable to rotate the image\n    rotatable: true,\n\n    // Enable to scale the image\n    scalable: true,\n\n    // Enable to zoom the image\n    zoomable: true,\n\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n\n    // Enable to move the crop box\n    cropBoxMovable: true,\n\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: 200,\n    minContainerHeight: 100,\n\n    // Shortcuts of events\n    build: null,\n    built: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n\n  Cropper.setDefaults = function (options) {\n    $.extend(Cropper.DEFAULTS, options);\n  };\n\n  Cropper.TEMPLATE = (\n    '<div class=\"cropper-container\">' +\n      '<div class=\"cropper-wrap-box\">' +\n        '<div class=\"cropper-canvas\"></div>' +\n      '</div>' +\n      '<div class=\"cropper-drag-box\"></div>' +\n      '<div class=\"cropper-crop-box\">' +\n        '<span class=\"cropper-view-box\"></span>' +\n        '<span class=\"cropper-dashed dashed-h\"></span>' +\n        '<span class=\"cropper-dashed dashed-v\"></span>' +\n        '<span class=\"cropper-center\"></span>' +\n        '<span class=\"cropper-face\"></span>' +\n        '<span class=\"cropper-line line-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-line line-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-line line-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-line line-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-point point-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-point point-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-point point-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-ne\" data-action=\"ne\"></span>' +\n        '<span class=\"cropper-point point-nw\" data-action=\"nw\"></span>' +\n        '<span class=\"cropper-point point-sw\" data-action=\"sw\"></span>' +\n        '<span class=\"cropper-point point-se\" data-action=\"se\"></span>' +\n      '</div>' +\n    '</div>'\n  );\n\n  // Save the other cropper\n  Cropper.other = $.fn.cropper;\n\n  // Register as jQuery plugin\n  $.fn.cropper = function (option) {\n    var args = toArray(arguments, 1);\n    var result;\n\n    this.each(function () {\n      var $this = $(this);\n      var data = $this.data(NAMESPACE);\n      var options;\n      var fn;\n\n      if (!data) {\n        if (/destroy/.test(option)) {\n          return;\n        }\n\n        options = $.extend({}, $this.data(), $.isPlainObject(option) && option);\n        $this.data(NAMESPACE, (data = new Cropper(this, options)));\n      }\n\n      if (typeof option === 'string' && $.isFunction(fn = data[option])) {\n        result = fn.apply(data, args);\n      }\n    });\n\n    return isUndefined(result) ? this : result;\n  };\n\n  $.fn.cropper.Constructor = Cropper;\n  $.fn.cropper.setDefaults = Cropper.setDefaults;\n\n  // No conflict\n  $.fn.cropper.noConflict = function () {\n    $.fn.cropper = Cropper.other;\n    return this;\n  };\n\n});\n\n\n/***/ }),\n\n/***/ \"dYvO\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($) {var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable comma-dangle, no-unused-vars, class-methods-use-this, quotes, consistent-return, func-names, prefer-arrow-callback, space-before-function-paren, max-len */\n/* global Flash */\n\n(function (global) {\n  var Profile = function () {\n    function Profile() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          form = _ref.form;\n\n      _classCallCheck(this, Profile);\n\n      this.onSubmitForm = this.onSubmitForm.bind(this);\n      this.form = form || $('.edit-user');\n      this.bindEvents();\n      this.initAvatarGlCrop();\n    }\n\n    _createClass(Profile, [{\n      key: 'initAvatarGlCrop',\n      value: function initAvatarGlCrop() {\n        var cropOpts = {\n          filename: '.js-avatar-filename',\n          previewImage: '.avatar-image .avatar',\n          modalCrop: '.modal-profile-crop',\n          pickImageEl: '.js-choose-user-avatar-button',\n          uploadImageBtn: '.js-upload-user-avatar',\n          modalCropImg: '.modal-profile-crop-image'\n        };\n        this.avatarGlCrop = $('.js-user-avatar-input').glCrop(cropOpts).data('glcrop');\n      }\n    }, {\n      key: 'bindEvents',\n      value: function bindEvents() {\n        $('.js-preferences-form').on('change.preference', 'input[type=radio]', this.submitForm);\n        $('#user_notification_email').on('change', this.submitForm);\n        $('.update-username').on('ajax:before', this.beforeUpdateUsername);\n        $('.update-username').on('ajax:complete', this.afterUpdateUsername);\n        $('.update-notifications').on('ajax:success', this.onUpdateNotifs);\n        this.form.on('submit', this.onSubmitForm);\n      }\n    }, {\n      key: 'submitForm',\n      value: function submitForm() {\n        return $(this).parents('form').submit();\n      }\n    }, {\n      key: 'onSubmitForm',\n      value: function onSubmitForm(e) {\n        e.preventDefault();\n        return this.saveForm();\n      }\n    }, {\n      key: 'beforeUpdateUsername',\n      value: function beforeUpdateUsername() {\n        $('.loading-username', this).removeClass('hidden');\n      }\n    }, {\n      key: 'afterUpdateUsername',\n      value: function afterUpdateUsername() {\n        $('.loading-username', this).addClass('hidden');\n        $('button[type=submit]', this).enable();\n      }\n    }, {\n      key: 'onUpdateNotifs',\n      value: function onUpdateNotifs(e, data) {\n        return data.saved ? new Flash(\"Notification settings saved\", \"notice\") : new Flash(\"Failed to save new settings\", \"alert\");\n      }\n    }, {\n      key: 'saveForm',\n      value: function saveForm() {\n        var self = this;\n        var formData = new FormData(this.form[0]);\n        var avatarBlob = this.avatarGlCrop.getBlob();\n\n        if (avatarBlob != null) {\n          formData.append('user[avatar]', avatarBlob, 'avatar.png');\n        }\n\n        return $.ajax({\n          url: this.form.attr('action'),\n          type: this.form.attr('method'),\n          data: formData,\n          dataType: \"json\",\n          processData: false,\n          contentType: false,\n          success: function success(response) {\n            return new Flash(response.message, 'notice');\n          },\n          error: function error(jqXHR) {\n            return new Flash(jqXHR.responseJSON.message, 'alert');\n          },\n          complete: function complete() {\n            window.scrollTo(0, 0);\n            // Enable submit button after requests ends\n            return self.form.find(':input[disabled]').enable();\n          }\n        });\n      }\n    }]);\n\n    return Profile;\n  }();\n\n  $(function () {\n    $(document).on('input.ssh_key', '#key_key', function () {\n      var $title = $('#key_title');\n      var comment = $(this).val().match(/^\\S+ \\S+ (.+)\\n?$/);\n\n      // Extract the SSH Key title from its comment\n      if (comment && comment.length > 1) {\n        return $title.val(comment[1]).change();\n      }\n    });\n    if (global.utils.getPagePath() === 'profiles') {\n      return new Profile();\n    }\n  });\n})(window.gl || (window.gl = {}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"lwLq\")))\n\n/***/ })\n\n},[\"RUZQ\"]);\n\n\n// WEBPACK FOOTER //\n// profile.bfc54bd40bc9a6938148.bundle.js","require('./gl_crop');\nrequire('./profile');\n\n\n\n// WEBPACK FOOTER //\n// ./profile/profile_bundle.js","/* eslint-disable no-useless-escape, max-len, quotes, no-var, no-underscore-dangle, func-names, space-before-function-paren, no-unused-vars, no-return-assign, object-shorthand, one-var, one-var-declaration-per-line, comma-dangle, consistent-return, class-methods-use-this, new-parens */\n\nimport 'vendor/cropper';\n\n((global) => {\n  // Matches everything but the file name\n  const FILENAMEREGEX = /^.*[\\\\\\/]/;\n\n  class GitLabCrop {\n    constructor(input, { filename, previewImage, modalCrop, pickImageEl, uploadImageBtn, modalCropImg,\n        exportWidth = 200, exportHeight = 200, cropBoxWidth = 200, cropBoxHeight = 200 } = {}) {\n      this.onUploadImageBtnClick = this.onUploadImageBtnClick.bind(this);\n      this.onModalHide = this.onModalHide.bind(this);\n      this.onModalShow = this.onModalShow.bind(this);\n      this.onPickImageClick = this.onPickImageClick.bind(this);\n      this.fileInput = $(input);\n      this.modalCropImg = _.isString(this.modalCropImg) ? $(this.modalCropImg) : this.modalCropImg;\n      this.fileInput.attr('name', `${this.fileInput.attr('name')}-trigger`).attr('id', `${this.fileInput.attr('id')}-trigger`);\n      this.exportWidth = exportWidth;\n      this.exportHeight = exportHeight;\n      this.cropBoxWidth = cropBoxWidth;\n      this.cropBoxHeight = cropBoxHeight;\n      this.form = this.fileInput.parents('form');\n      this.filename = filename;\n      this.previewImage = previewImage;\n      this.modalCrop = modalCrop;\n      this.pickImageEl = pickImageEl;\n      this.uploadImageBtn = uploadImageBtn;\n      this.modalCropImg = modalCropImg;\n      this.filename = this.getElement(filename);\n      this.previewImage = this.getElement(previewImage);\n      this.pickImageEl = this.getElement(pickImageEl);\n      this.modalCrop = _.isString(modalCrop) ? $(modalCrop) : modalCrop;\n      this.uploadImageBtn = _.isString(uploadImageBtn) ? $(uploadImageBtn) : uploadImageBtn;\n      this.modalCropImg = _.isString(modalCropImg) ? $(modalCropImg) : modalCropImg;\n      this.cropActionsBtn = this.modalCrop.find('[data-method]');\n      this.bindEvents();\n    }\n\n    getElement(selector) {\n      return $(selector, this.form);\n    }\n\n    bindEvents() {\n      var _this;\n      _this = this;\n      this.fileInput.on('change', function(e) {\n        return _this.onFileInputChange(e, this);\n      });\n      this.pickImageEl.on('click', this.onPickImageClick);\n      this.modalCrop.on('shown.bs.modal', this.onModalShow);\n      this.modalCrop.on('hidden.bs.modal', this.onModalHide);\n      this.uploadImageBtn.on('click', this.onUploadImageBtnClick);\n      this.cropActionsBtn.on('click', function(e) {\n        var btn;\n        btn = this;\n        return _this.onActionBtnClick(btn);\n      });\n      return this.croppedImageBlob = null;\n    }\n\n    onPickImageClick() {\n      return this.fileInput.trigger('click');\n    }\n\n    onModalShow() {\n      var _this;\n      _this = this;\n      return this.modalCropImg.cropper({\n        viewMode: 1,\n        center: false,\n        aspectRatio: 1,\n        modal: true,\n        scalable: false,\n        rotatable: false,\n        zoomable: true,\n        dragMode: 'move',\n        guides: false,\n        zoomOnTouch: false,\n        zoomOnWheel: false,\n        cropBoxMovable: false,\n        cropBoxResizable: false,\n        toggleDragModeOnDblclick: false,\n        built: function() {\n          var $image, container, cropBoxHeight, cropBoxWidth;\n          $image = $(this);\n          container = $image.cropper('getContainerData');\n          cropBoxWidth = _this.cropBoxWidth;\n          cropBoxHeight = _this.cropBoxHeight;\n          return $image.cropper('setCropBoxData', {\n            width: cropBoxWidth,\n            height: cropBoxHeight,\n            left: (container.width - cropBoxWidth) / 2,\n            top: (container.height - cropBoxHeight) / 2\n          });\n        }\n      });\n    }\n\n    onModalHide() {\n      return this.modalCropImg.attr('src', '').cropper('destroy');\n    }\n\n    onUploadImageBtnClick(e) {\n      e.preventDefault();\n      this.setBlob();\n      this.setPreview();\n      this.modalCrop.modal('hide');\n      return this.fileInput.val('');\n    }\n\n    onActionBtnClick(btn) {\n      var data, result;\n      data = $(btn).data();\n      if (this.modalCropImg.data('cropper') && data.method) {\n        return result = this.modalCropImg.cropper(data.method, data.option);\n      }\n    }\n\n    onFileInputChange(e, input) {\n      return this.readFile(input);\n    }\n\n    readFile(input) {\n      var _this, reader;\n      _this = this;\n      reader = new FileReader;\n      reader.onload = () => {\n        _this.modalCropImg.attr('src', reader.result);\n        return _this.modalCrop.modal('show');\n      };\n      return reader.readAsDataURL(input.files[0]);\n    }\n\n    dataURLtoBlob(dataURL) {\n      var array, binary, i, k, len, v;\n      binary = atob(dataURL.split(',')[1]);\n      array = [];\n      for (k = i = 0, len = binary.length; i < len; k = (i += 1)) {\n        v = binary[k];\n        array.push(binary.charCodeAt(k));\n      }\n      return new Blob([new Uint8Array(array)], {\n        type: 'image/png'\n      });\n    }\n\n    setPreview() {\n      var filename;\n      this.previewImage.attr('src', this.dataURL);\n      filename = this.fileInput.val().replace(FILENAMEREGEX, '');\n      return this.filename.text(filename);\n    }\n\n    setBlob() {\n      this.dataURL = this.modalCropImg.cropper('getCroppedCanvas', {\n        width: 200,\n        height: 200\n      }).toDataURL('image/png');\n      return this.croppedImageBlob = this.dataURLtoBlob(this.dataURL);\n    }\n\n    getBlob() {\n      return this.croppedImageBlob;\n    }\n  }\n\n  $.fn.glCrop = function(opts) {\n    return this.each(function() {\n      return $(this).data('glcrop', new GitLabCrop(this, opts));\n    });\n  };\n})(window.gl || (window.gl = {}));\n\n\n\n// WEBPACK FOOTER //\n// ./profile/gl_crop.js","/*!\n * Cropper v2.3.0\n * https://github.com/fengyuanchen/cropper\n *\n * Copyright (c) 2014-2016 Fengyuan Chen and contributors\n * Released under the MIT license\n *\n * Date: 2016-02-22T02:13:13.332Z\n */\n\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof exports === 'object') {\n    // Node / CommonJS\n    factory(require('jquery'));\n  } else {\n    // Browser globals.\n    factory(jQuery);\n  }\n})(function ($) {\n\n  'use strict';\n\n  // Globals\n  var $window = $(window);\n  var $document = $(document);\n  var location = window.location;\n  var navigator = window.navigator;\n  var ArrayBuffer = window.ArrayBuffer;\n  var Uint8Array = window.Uint8Array;\n  var DataView = window.DataView;\n  var btoa = window.btoa;\n\n  // Constants\n  var NAMESPACE = 'cropper';\n\n  // Classes\n  var CLASS_MODAL = 'cropper-modal';\n  var CLASS_HIDE = 'cropper-hide';\n  var CLASS_HIDDEN = 'cropper-hidden';\n  var CLASS_INVISIBLE = 'cropper-invisible';\n  var CLASS_MOVE = 'cropper-move';\n  var CLASS_CROP = 'cropper-crop';\n  var CLASS_DISABLED = 'cropper-disabled';\n  var CLASS_BG = 'cropper-bg';\n\n  // Events\n  var EVENT_MOUSE_DOWN = 'mousedown touchstart pointerdown MSPointerDown';\n  var EVENT_MOUSE_MOVE = 'mousemove touchmove pointermove MSPointerMove';\n  var EVENT_MOUSE_UP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';\n  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_LOAD = 'load.' + NAMESPACE;\n  var EVENT_ERROR = 'error.' + NAMESPACE;\n  var EVENT_RESIZE = 'resize.' + NAMESPACE; // Bind to window with namespace\n  var EVENT_BUILD = 'build.' + NAMESPACE;\n  var EVENT_BUILT = 'built.' + NAMESPACE;\n  var EVENT_CROP_START = 'cropstart.' + NAMESPACE;\n  var EVENT_CROP_MOVE = 'cropmove.' + NAMESPACE;\n  var EVENT_CROP_END = 'cropend.' + NAMESPACE;\n  var EVENT_CROP = 'crop.' + NAMESPACE;\n  var EVENT_ZOOM = 'zoom.' + NAMESPACE;\n\n  // RegExps\n  var REGEXP_ACTIONS = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/;\n  var REGEXP_DATA_URL = /^data\\:/;\n  var REGEXP_DATA_URL_HEAD = /^data\\:([^\\;]+)\\;base64,/;\n  var REGEXP_DATA_URL_JPEG = /^data\\:image\\/jpeg.*;base64,/;\n\n  // Data keys\n  var DATA_PREVIEW = 'preview';\n  var DATA_ACTION = 'action';\n\n  // Actions\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_NONE = 'none';\n\n  // Supports\n  var SUPPORT_CANVAS = $.isFunction($('<canvas>')[0].getContext);\n  var IS_SAFARI = navigator && /safari/i.test(navigator.userAgent) && /apple computer/i.test(navigator.vendor);\n\n  // Maths\n  var num = Number;\n  var min = Math.min;\n  var max = Math.max;\n  var abs = Math.abs;\n  var sin = Math.sin;\n  var cos = Math.cos;\n  var sqrt = Math.sqrt;\n  var round = Math.round;\n  var floor = Math.floor;\n\n  // Utilities\n  var fromCharCode = String.fromCharCode;\n\n  function isNumber(n) {\n    return typeof n === 'number' && !isNaN(n);\n  }\n\n  function isUndefined(n) {\n    return typeof n === 'undefined';\n  }\n\n  function toArray(obj, offset) {\n    var args = [];\n\n    // This is necessary for IE8\n    if (isNumber(offset)) {\n      args.push(offset);\n    }\n\n    return args.slice.apply(obj, args);\n  }\n\n  // Custom proxy to avoid jQuery's guid\n  function proxy(fn, context) {\n    var args = toArray(arguments, 2);\n\n    return function () {\n      return fn.apply(context, args.concat(toArray(arguments)));\n    };\n  }\n\n  function isCrossOriginURL(url) {\n    var parts = url.match(/^(https?:)\\/\\/([^\\:\\/\\?#]+):?(\\d*)/i);\n\n    return parts && (\n      parts[1] !== location.protocol ||\n      parts[2] !== location.hostname ||\n      parts[3] !== location.port\n    );\n  }\n\n  function addTimestamp(url) {\n    var timestamp = 'timestamp=' + (new Date()).getTime();\n\n    return (url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp);\n  }\n\n  function getCrossOrigin(crossOrigin) {\n    return crossOrigin ? ' crossOrigin=\"' + crossOrigin + '\"' : '';\n  }\n\n  function getImageSize(image, callback) {\n    var newImage;\n\n    // Modern browsers (ignore Safari, #120 & #509)\n    if (image.naturalWidth && !IS_SAFARI) {\n      return callback(image.naturalWidth, image.naturalHeight);\n    }\n\n    // IE8: Don't use `new Image()` here (#319)\n    newImage = document.createElement('img');\n\n    newImage.onload = function () {\n      callback(this.width, this.height);\n    };\n\n    newImage.src = image.src;\n  }\n\n  function getTransform(options) {\n    var transforms = [];\n    var rotate = options.rotate;\n    var scaleX = options.scaleX;\n    var scaleY = options.scaleY;\n\n    if (isNumber(rotate)) {\n      transforms.push('rotate(' + rotate + 'deg)');\n    }\n\n    if (isNumber(scaleX) && isNumber(scaleY)) {\n      transforms.push('scale(' + scaleX + ',' + scaleY + ')');\n    }\n\n    return transforms.length ? transforms.join(' ') : 'none';\n  }\n\n  function getRotatedSizes(data, isReversed) {\n    var deg = abs(data.degree) % 180;\n    var arc = (deg > 90 ? (180 - deg) : deg) * Math.PI / 180;\n    var sinArc = sin(arc);\n    var cosArc = cos(arc);\n    var width = data.width;\n    var height = data.height;\n    var aspectRatio = data.aspectRatio;\n    var newWidth;\n    var newHeight;\n\n    if (!isReversed) {\n      newWidth = width * cosArc + height * sinArc;\n      newHeight = width * sinArc + height * cosArc;\n    } else {\n      newWidth = width / (cosArc + sinArc / aspectRatio);\n      newHeight = newWidth / aspectRatio;\n    }\n\n    return {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  function getSourceCanvas(image, data) {\n    var canvas = $('<canvas>')[0];\n    var context = canvas.getContext('2d');\n    var dstX = 0;\n    var dstY = 0;\n    var dstWidth = data.naturalWidth;\n    var dstHeight = data.naturalHeight;\n    var rotate = data.rotate;\n    var scaleX = data.scaleX;\n    var scaleY = data.scaleY;\n    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);\n    var rotatable = isNumber(rotate) && rotate !== 0;\n    var advanced = rotatable || scalable;\n    var canvasWidth = dstWidth * abs(scaleX || 1);\n    var canvasHeight = dstHeight * abs(scaleY || 1);\n    var translateX;\n    var translateY;\n    var rotated;\n\n    if (scalable) {\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    if (rotatable) {\n      rotated = getRotatedSizes({\n        width: canvasWidth,\n        height: canvasHeight,\n        degree: rotate\n      });\n\n      canvasWidth = rotated.width;\n      canvasHeight = rotated.height;\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    if (advanced) {\n      dstX = -dstWidth / 2;\n      dstY = -dstHeight / 2;\n\n      context.save();\n      context.translate(translateX, translateY);\n    }\n\n    if (rotatable) {\n      context.rotate(rotate * Math.PI / 180);\n    }\n\n    // Should call `scale` after rotated\n    if (scalable) {\n      context.scale(scaleX, scaleY);\n    }\n\n    context.drawImage(image, floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n\n    if (advanced) {\n      context.restore();\n    }\n\n    return canvas;\n  }\n\n  function getTouchesCenter(touches) {\n    var length = touches.length;\n    var pageX = 0;\n    var pageY = 0;\n\n    if (length) {\n      $.each(touches, function (i, touch) {\n        pageX += touch.pageX;\n        pageY += touch.pageY;\n      });\n\n      pageX /= length;\n      pageY /= length;\n    }\n\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    var i;\n\n    for (i = start, length += start; i < length; i++) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n\n    return str;\n  }\n\n  function getOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var length = dataView.byteLength;\n    var orientation;\n    var exifIDCode;\n    var tiffOffset;\n    var firstIFDOffset;\n    var littleEndian;\n    var endianness;\n    var app1Start;\n    var ifdStart;\n    var offset;\n    var i;\n\n    // Only handle JPEG image (start by 0xFFD8)\n    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n      offset = 2;\n\n      while (offset < length) {\n        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n          app1Start = offset;\n          break;\n        }\n\n        offset++;\n      }\n    }\n\n    if (app1Start) {\n      exifIDCode = app1Start + 4;\n      tiffOffset = app1Start + 10;\n\n      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n        endianness = dataView.getUint16(tiffOffset);\n        littleEndian = endianness === 0x4949;\n\n        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n      }\n    }\n\n    if (ifdStart) {\n      length = dataView.getUint16(ifdStart, littleEndian);\n\n      for (i = 0; i < length; i++) {\n        offset = ifdStart + i * 12 + 2;\n\n        if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {\n\n          // 8 is the offset of the current tag's value\n          offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(offset, littleEndian);\n\n          // Override the orientation with its default value for Safari (#120)\n          if (IS_SAFARI) {\n            dataView.setUint16(offset, 1, littleEndian);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return orientation;\n  }\n\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var length = binary.length;\n    var arrayBuffer = new ArrayBuffer(length);\n    var dataView = new Uint8Array(arrayBuffer);\n    var i;\n\n    for (i = 0; i < length; i++) {\n      dataView[i] = binary.charCodeAt(i);\n    }\n\n    return arrayBuffer;\n  }\n\n  // Only available for JPEG image\n  function arrayBufferToDataURL(arrayBuffer) {\n    var dataView = new Uint8Array(arrayBuffer);\n    var length = dataView.length;\n    var base64 = '';\n    var i;\n\n    for (i = 0; i < length; i++) {\n      base64 += fromCharCode(dataView[i]);\n    }\n\n    return 'data:image/jpeg;base64,' + btoa(base64);\n  }\n\n  function Cropper(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, Cropper.DEFAULTS, $.isPlainObject(options) && options);\n    this.isLoaded = false;\n    this.isBuilt = false;\n    this.isCompleted = false;\n    this.isRotated = false;\n    this.isCropped = false;\n    this.isDisabled = false;\n    this.isReplaced = false;\n    this.isLimited = false;\n    this.wheeling = false;\n    this.isImg = false;\n    this.originalUrl = '';\n    this.canvas = null;\n    this.cropBox = null;\n    this.init();\n  }\n\n  Cropper.prototype = {\n    constructor: Cropper,\n\n    init: function () {\n      var $this = this.$element;\n      var url;\n\n      if ($this.is('img')) {\n        this.isImg = true;\n\n        // Should use `$.fn.attr` here. e.g.: \"img/picture.jpg\"\n        this.originalUrl = url = $this.attr('src');\n\n        // Stop when it's a blank image\n        if (!url) {\n          return;\n        }\n\n        // Should use `$.fn.prop` here. e.g.: \"http://example.com/img/picture.jpg\"\n        url = $this.prop('src');\n      } else if ($this.is('canvas') && SUPPORT_CANVAS) {\n        url = $this[0].toDataURL();\n      }\n\n      this.load(url);\n    },\n\n    // A shortcut for triggering custom events\n    trigger: function (type, data) {\n      var e = $.Event(type, data);\n\n      this.$element.trigger(e);\n\n      return e;\n    },\n\n    load: function (url) {\n      var options = this.options;\n      var $this = this.$element;\n      var read;\n      var xhr;\n\n      if (!url) {\n        return;\n      }\n\n      // Trigger build event first\n      $this.one(EVENT_BUILD, options.build);\n\n      if (this.trigger(EVENT_BUILD).isDefaultPrevented()) {\n        return;\n      }\n\n      this.url = url;\n      this.image = {};\n\n      if (!options.checkOrientation || !ArrayBuffer) {\n        return this.clone();\n      }\n\n      read = $.proxy(this.read, this);\n\n      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari\n      if (REGEXP_DATA_URL.test(url)) {\n        return REGEXP_DATA_URL_JPEG.test(url) ?\n          read(dataURLToArrayBuffer(url)) :\n          this.clone();\n      }\n\n      xhr = new XMLHttpRequest();\n\n      xhr.onerror = xhr.onabort = $.proxy(function () {\n        this.clone();\n      }, this);\n\n      xhr.onload = function () {\n        read(this.response);\n      };\n\n      xhr.open('get', url);\n      xhr.responseType = 'arraybuffer';\n      xhr.send();\n    },\n\n    read: function (arrayBuffer) {\n      var options = this.options;\n      var orientation = getOrientation(arrayBuffer);\n      var image = this.image;\n      var rotate;\n      var scaleX;\n      var scaleY;\n\n      if (orientation > 1) {\n        this.url = arrayBufferToDataURL(arrayBuffer);\n\n        switch (orientation) {\n\n          // flip horizontal\n          case 2:\n            scaleX = -1;\n            break;\n\n          // rotate left 180°\n          case 3:\n            rotate = -180;\n            break;\n\n          // flip vertical\n          case 4:\n            scaleY = -1;\n            break;\n\n          // flip vertical + rotate right 90°\n          case 5:\n            rotate = 90;\n            scaleY = -1;\n            break;\n\n          // rotate right 90°\n          case 6:\n            rotate = 90;\n            break;\n\n          // flip horizontal + rotate right 90°\n          case 7:\n            rotate = 90;\n            scaleX = -1;\n            break;\n\n          // rotate left 90°\n          case 8:\n            rotate = -90;\n            break;\n        }\n      }\n\n      if (options.rotatable) {\n        image.rotate = rotate;\n      }\n\n      if (options.scalable) {\n        image.scaleX = scaleX;\n        image.scaleY = scaleY;\n      }\n\n      this.clone();\n    },\n\n    clone: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var url = this.url;\n      var crossOrigin = '';\n      var crossOriginUrl;\n      var $clone;\n\n      if (options.checkCrossOrigin && isCrossOriginURL(url)) {\n        crossOrigin = $this.prop('crossOrigin');\n\n        if (crossOrigin) {\n          crossOriginUrl = url;\n        } else {\n          crossOrigin = 'anonymous';\n\n          // Bust cache (#148) when there is not a \"crossOrigin\" property\n          crossOriginUrl = addTimestamp(url);\n        }\n      }\n\n      this.crossOrigin = crossOrigin;\n      this.crossOriginUrl = crossOriginUrl;\n      this.$clone = $clone = $('<img' + getCrossOrigin(crossOrigin) + ' src=\"' + (crossOriginUrl || url) + '\">');\n\n      if (this.isImg) {\n        if ($this[0].complete) {\n          this.start();\n        } else {\n          $this.one(EVENT_LOAD, $.proxy(this.start, this));\n        }\n      } else {\n        $clone.\n          one(EVENT_LOAD, $.proxy(this.start, this)).\n          one(EVENT_ERROR, $.proxy(this.stop, this)).\n          addClass(CLASS_HIDE).\n          insertAfter($this);\n      }\n    },\n\n    start: function () {\n      var $image = this.$element;\n      var $clone = this.$clone;\n\n      if (!this.isImg) {\n        $clone.off(EVENT_ERROR, this.stop);\n        $image = $clone;\n      }\n\n      getImageSize($image[0], $.proxy(function (naturalWidth, naturalHeight) {\n        $.extend(this.image, {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight,\n          aspectRatio: naturalWidth / naturalHeight\n        });\n\n        this.isLoaded = true;\n        this.build();\n      }, this));\n    },\n\n    stop: function () {\n      this.$clone.remove();\n      this.$clone = null;\n    },\n\n    build: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $clone = this.$clone;\n      var $cropper;\n      var $cropBox;\n      var $face;\n\n      if (!this.isLoaded) {\n        return;\n      }\n\n      // Unbuild first when replace\n      if (this.isBuilt) {\n        this.unbuild();\n      }\n\n      // Create cropper elements\n      this.$container = $this.parent();\n      this.$cropper = $cropper = $(Cropper.TEMPLATE);\n      this.$canvas = $cropper.find('.cropper-canvas').append($clone);\n      this.$dragBox = $cropper.find('.cropper-drag-box');\n      this.$cropBox = $cropBox = $cropper.find('.cropper-crop-box');\n      this.$viewBox = $cropper.find('.cropper-view-box');\n      this.$face = $face = $cropBox.find('.cropper-face');\n\n      // Hide the original image\n      $this.addClass(CLASS_HIDDEN).after($cropper);\n\n      // Show the clone image if is hidden\n      if (!this.isImg) {\n        $clone.removeClass(CLASS_HIDE);\n      }\n\n      this.initPreview();\n      this.bind();\n\n      options.aspectRatio = max(0, options.aspectRatio) || NaN;\n      options.viewMode = max(0, min(3, round(options.viewMode))) || 0;\n\n      if (options.autoCrop) {\n        this.isCropped = true;\n\n        if (options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      } else {\n        $cropBox.addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.guides) {\n        $cropBox.find('.cropper-dashed').addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.center) {\n        $cropBox.find('.cropper-center').addClass(CLASS_HIDDEN);\n      }\n\n      if (options.cropBoxMovable) {\n        $face.addClass(CLASS_MOVE).data(DATA_ACTION, ACTION_ALL);\n      }\n\n      if (!options.highlight) {\n        $face.addClass(CLASS_INVISIBLE);\n      }\n\n      if (options.background) {\n        $cropper.addClass(CLASS_BG);\n      }\n\n      if (!options.cropBoxResizable) {\n        $cropBox.find('.cropper-line, .cropper-point').addClass(CLASS_HIDDEN);\n      }\n\n      this.setDragMode(options.dragMode);\n      this.render();\n      this.isBuilt = true;\n      this.setData(options.data);\n      $this.one(EVENT_BUILT, options.built);\n\n      // Trigger the built event asynchronously to keep `data('cropper')` is defined\n      setTimeout($.proxy(function () {\n        this.trigger(EVENT_BUILT);\n        this.isCompleted = true;\n      }, this), 0);\n    },\n\n    unbuild: function () {\n      if (!this.isBuilt) {\n        return;\n      }\n\n      this.isBuilt = false;\n      this.isCompleted = false;\n      this.initialImage = null;\n\n      // Clear `initialCanvas` is necessary when replace\n      this.initialCanvas = null;\n      this.initialCropBox = null;\n      this.container = null;\n      this.canvas = null;\n\n      // Clear `cropBox` is necessary when replace\n      this.cropBox = null;\n      this.unbind();\n\n      this.resetPreview();\n      this.$preview = null;\n\n      this.$viewBox = null;\n      this.$cropBox = null;\n      this.$dragBox = null;\n      this.$canvas = null;\n      this.$container = null;\n\n      this.$cropper.remove();\n      this.$cropper = null;\n    },\n\n    render: function () {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    initContainer: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $container = this.$container;\n      var $cropper = this.$cropper;\n\n      $cropper.addClass(CLASS_HIDDEN);\n      $this.removeClass(CLASS_HIDDEN);\n\n      $cropper.css((this.container = {\n        width: max($container.width(), num(options.minContainerWidth) || 200),\n        height: max($container.height(), num(options.minContainerHeight) || 100)\n      }));\n\n      $this.addClass(CLASS_HIDDEN);\n      $cropper.removeClass(CLASS_HIDDEN);\n    },\n\n    // Canvas (image wrapper)\n    initCanvas: function () {\n      var viewMode = this.options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var image = this.image;\n      var imageNaturalWidth = image.naturalWidth;\n      var imageNaturalHeight = image.naturalHeight;\n      var is90Degree = abs(image.rotate) === 90;\n      var naturalWidth = is90Degree ? imageNaturalHeight : imageNaturalWidth;\n      var naturalHeight = is90Degree ? imageNaturalWidth : imageNaturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerWidth;\n      var canvasHeight = containerHeight;\n      var canvas;\n\n      if (containerHeight * aspectRatio > containerWidth) {\n        if (viewMode === 3) {\n          canvasWidth = containerHeight * aspectRatio;\n        } else {\n          canvasHeight = containerWidth / aspectRatio;\n        }\n      } else {\n        if (viewMode === 3) {\n          canvasHeight = containerWidth / aspectRatio;\n        } else {\n          canvasWidth = containerHeight * aspectRatio;\n        }\n      }\n\n      canvas = {\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        aspectRatio: aspectRatio,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n\n      canvas.oldLeft = canvas.left = (containerWidth - canvasWidth) / 2;\n      canvas.oldTop = canvas.top = (containerHeight - canvasHeight) / 2;\n\n      this.canvas = canvas;\n      this.isLimited = (viewMode === 1 || viewMode === 2);\n      this.limitCanvas(true, true);\n      this.initialImage = $.extend({}, image);\n      this.initialCanvas = $.extend({}, canvas);\n    },\n\n    limitCanvas: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var viewMode = options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n      var cropBox = this.cropBox;\n      var isCropped = this.isCropped && cropBox;\n      var minCanvasWidth;\n      var minCanvasHeight;\n      var newCanvasLeft;\n      var newCanvasTop;\n\n      if (isSizeLimited) {\n        minCanvasWidth = num(options.minCanvasWidth) || 0;\n        minCanvasHeight = num(options.minCanvasHeight) || 0;\n\n        if (viewMode) {\n          if (viewMode > 1) {\n            minCanvasWidth = max(minCanvasWidth, containerWidth);\n            minCanvasHeight = max(minCanvasHeight, containerHeight);\n\n            if (viewMode === 3) {\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          } else {\n            if (minCanvasWidth) {\n              minCanvasWidth = max(minCanvasWidth, isCropped ? cropBox.width : 0);\n            } else if (minCanvasHeight) {\n              minCanvasHeight = max(minCanvasHeight, isCropped ? cropBox.height : 0);\n            } else if (isCropped) {\n              minCanvasWidth = cropBox.width;\n              minCanvasHeight = cropBox.height;\n\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          }\n        }\n\n        if (minCanvasWidth && minCanvasHeight) {\n          if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n            minCanvasHeight = minCanvasWidth / aspectRatio;\n          } else {\n            minCanvasWidth = minCanvasHeight * aspectRatio;\n          }\n        } else if (minCanvasWidth) {\n          minCanvasHeight = minCanvasWidth / aspectRatio;\n        } else if (minCanvasHeight) {\n          minCanvasWidth = minCanvasHeight * aspectRatio;\n        }\n\n        canvas.minWidth = minCanvasWidth;\n        canvas.minHeight = minCanvasHeight;\n        canvas.maxWidth = Infinity;\n        canvas.maxHeight = Infinity;\n      }\n\n      if (isPositionLimited) {\n        if (viewMode) {\n          newCanvasLeft = containerWidth - canvas.width;\n          newCanvasTop = containerHeight - canvas.height;\n\n          canvas.minLeft = min(0, newCanvasLeft);\n          canvas.minTop = min(0, newCanvasTop);\n          canvas.maxLeft = max(0, newCanvasLeft);\n          canvas.maxTop = max(0, newCanvasTop);\n\n          if (isCropped && this.isLimited) {\n            canvas.minLeft = min(\n              cropBox.left,\n              cropBox.left + cropBox.width - canvas.width\n            );\n            canvas.minTop = min(\n              cropBox.top,\n              cropBox.top + cropBox.height - canvas.height\n            );\n            canvas.maxLeft = cropBox.left;\n            canvas.maxTop = cropBox.top;\n\n            if (viewMode === 2) {\n              if (canvas.width >= containerWidth) {\n                canvas.minLeft = min(0, newCanvasLeft);\n                canvas.maxLeft = max(0, newCanvasLeft);\n              }\n\n              if (canvas.height >= containerHeight) {\n                canvas.minTop = min(0, newCanvasTop);\n                canvas.maxTop = max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvas.minLeft = -canvas.width;\n          canvas.minTop = -canvas.height;\n          canvas.maxLeft = containerWidth;\n          canvas.maxTop = containerHeight;\n        }\n      }\n    },\n\n    renderCanvas: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var rotate = image.rotate;\n      var naturalWidth = image.naturalWidth;\n      var naturalHeight = image.naturalHeight;\n      var aspectRatio;\n      var rotated;\n\n      if (this.isRotated) {\n        this.isRotated = false;\n\n        // Computes rotated sizes with image sizes\n        rotated = getRotatedSizes({\n          width: image.width,\n          height: image.height,\n          degree: rotate\n        });\n\n        aspectRatio = rotated.width / rotated.height;\n\n        if (aspectRatio !== canvas.aspectRatio) {\n          canvas.left -= (rotated.width - canvas.width) / 2;\n          canvas.top -= (rotated.height - canvas.height) / 2;\n          canvas.width = rotated.width;\n          canvas.height = rotated.height;\n          canvas.aspectRatio = aspectRatio;\n          canvas.naturalWidth = naturalWidth;\n          canvas.naturalHeight = naturalHeight;\n\n          // Computes rotated sizes with natural image sizes\n          if (rotate % 180) {\n            rotated = getRotatedSizes({\n              width: naturalWidth,\n              height: naturalHeight,\n              degree: rotate\n            });\n\n            canvas.naturalWidth = rotated.width;\n            canvas.naturalHeight = rotated.height;\n          }\n\n          this.limitCanvas(true, false);\n        }\n      }\n\n      if (canvas.width > canvas.maxWidth || canvas.width < canvas.minWidth) {\n        canvas.left = canvas.oldLeft;\n      }\n\n      if (canvas.height > canvas.maxHeight || canvas.height < canvas.minHeight) {\n        canvas.top = canvas.oldTop;\n      }\n\n      canvas.width = min(max(canvas.width, canvas.minWidth), canvas.maxWidth);\n      canvas.height = min(max(canvas.height, canvas.minHeight), canvas.maxHeight);\n\n      this.limitCanvas(false, true);\n\n      canvas.oldLeft = canvas.left = min(max(canvas.left, canvas.minLeft), canvas.maxLeft);\n      canvas.oldTop = canvas.top = min(max(canvas.top, canvas.minTop), canvas.maxTop);\n\n      this.$canvas.css({\n        width: canvas.width,\n        height: canvas.height,\n        left: canvas.left,\n        top: canvas.top\n      });\n\n      this.renderImage();\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCropBox(true, true);\n      }\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    renderImage: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var reversed;\n\n      if (image.rotate) {\n        reversed = getRotatedSizes({\n          width: canvas.width,\n          height: canvas.height,\n          degree: image.rotate,\n          aspectRatio: image.aspectRatio\n        }, true);\n      }\n\n      $.extend(image, reversed ? {\n        width: reversed.width,\n        height: reversed.height,\n        left: (canvas.width - reversed.width) / 2,\n        top: (canvas.height - reversed.height) / 2\n      } : {\n        width: canvas.width,\n        height: canvas.height,\n        left: 0,\n        top: 0\n      });\n\n      this.$clone.css({\n        width: image.width,\n        height: image.height,\n        marginLeft: image.left,\n        marginTop: image.top,\n        transform: getTransform(image)\n      });\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    initCropBox: function () {\n      var options = this.options;\n      var canvas = this.canvas;\n      var aspectRatio = options.aspectRatio;\n      var autoCropArea = num(options.autoCropArea) || 0.8;\n      var cropBox = {\n            width: canvas.width,\n            height: canvas.height\n          };\n\n      if (aspectRatio) {\n        if (canvas.height * aspectRatio > canvas.width) {\n          cropBox.height = cropBox.width / aspectRatio;\n        } else {\n          cropBox.width = cropBox.height * aspectRatio;\n        }\n      }\n\n      this.cropBox = cropBox;\n      this.limitCropBox(true, true);\n\n      // Initialize auto crop area\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      // The width of auto crop area must large than \"minWidth\", and the height too. (#164)\n      cropBox.width = max(cropBox.minWidth, cropBox.width * autoCropArea);\n      cropBox.height = max(cropBox.minHeight, cropBox.height * autoCropArea);\n      cropBox.oldLeft = cropBox.left = canvas.left + (canvas.width - cropBox.width) / 2;\n      cropBox.oldTop = cropBox.top = canvas.top + (canvas.height - cropBox.height) / 2;\n\n      this.initialCropBox = $.extend({}, cropBox);\n    },\n\n    limitCropBox: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var isLimited = this.isLimited;\n      var minCropBoxWidth;\n      var minCropBoxHeight;\n      var maxCropBoxWidth;\n      var maxCropBoxHeight;\n\n      if (isSizeLimited) {\n        minCropBoxWidth = num(options.minCropBoxWidth) || 0;\n        minCropBoxHeight = num(options.minCropBoxHeight) || 0;\n\n        // The min/maxCropBoxWidth/Height must be less than containerWidth/Height\n        minCropBoxWidth = min(minCropBoxWidth, containerWidth);\n        minCropBoxHeight = min(minCropBoxHeight, containerHeight);\n        maxCropBoxWidth = min(containerWidth, isLimited ? canvas.width : containerWidth);\n        maxCropBoxHeight = min(containerHeight, isLimited ? canvas.height : containerHeight);\n\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        }\n\n        // The minWidth/Height must be less than maxWidth/Height\n        cropBox.minWidth = min(minCropBoxWidth, maxCropBoxWidth);\n        cropBox.minHeight = min(minCropBoxHeight, maxCropBoxHeight);\n        cropBox.maxWidth = maxCropBoxWidth;\n        cropBox.maxHeight = maxCropBoxHeight;\n      }\n\n      if (isPositionLimited) {\n        if (isLimited) {\n          cropBox.minLeft = max(0, canvas.left);\n          cropBox.minTop = max(0, canvas.top);\n          cropBox.maxLeft = min(containerWidth, canvas.left + canvas.width) - cropBox.width;\n          cropBox.maxTop = min(containerHeight, canvas.top + canvas.height) - cropBox.height;\n        } else {\n          cropBox.minLeft = 0;\n          cropBox.minTop = 0;\n          cropBox.maxLeft = containerWidth - cropBox.width;\n          cropBox.maxTop = containerHeight - cropBox.height;\n        }\n      }\n    },\n\n    renderCropBox: function () {\n      var options = this.options;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var cropBox = this.cropBox;\n\n      if (cropBox.width > cropBox.maxWidth || cropBox.width < cropBox.minWidth) {\n        cropBox.left = cropBox.oldLeft;\n      }\n\n      if (cropBox.height > cropBox.maxHeight || cropBox.height < cropBox.minHeight) {\n        cropBox.top = cropBox.oldTop;\n      }\n\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      this.limitCropBox(false, true);\n\n      cropBox.oldLeft = cropBox.left = min(max(cropBox.left, cropBox.minLeft), cropBox.maxLeft);\n      cropBox.oldTop = cropBox.top = min(max(cropBox.top, cropBox.minTop), cropBox.maxTop);\n\n      if (options.movable && options.cropBoxMovable) {\n\n        // Turn to move the canvas when the crop box is equal to the container\n        this.$face.data(DATA_ACTION, (cropBox.width === containerWidth && cropBox.height === containerHeight) ? ACTION_MOVE : ACTION_ALL);\n      }\n\n      this.$cropBox.css({\n        width: cropBox.width,\n        height: cropBox.height,\n        left: cropBox.left,\n        top: cropBox.top\n      });\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCanvas(true, true);\n      }\n\n      if (!this.isDisabled) {\n        this.output();\n      }\n    },\n\n    output: function () {\n      this.preview();\n\n      if (this.isCompleted) {\n        this.trigger(EVENT_CROP, this.getData());\n      } else if (!this.isBuilt) {\n\n        // Only trigger one crop event before complete\n        this.$element.one(EVENT_BUILT, $.proxy(function () {\n          this.trigger(EVENT_CROP, this.getData());\n        }, this));\n      }\n    },\n\n    initPreview: function () {\n      var crossOrigin = getCrossOrigin(this.crossOrigin);\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var $clone2;\n\n      this.$preview = $(this.options.preview);\n      this.$clone2 = $clone2 = $('<img' + crossOrigin + ' src=\"' + url + '\">');\n      this.$viewBox.html($clone2);\n      this.$preview.each(function () {\n        var $this = $(this);\n\n        // Save the original size for recover\n        $this.data(DATA_PREVIEW, {\n          width: $this.width(),\n          height: $this.height(),\n          html: $this.html()\n        });\n\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * (Occur only when margin-top <= -height)\n         */\n        $this.html(\n          '<img' + crossOrigin + ' src=\"' + url + '\" style=\"' +\n          'display:block;width:100%;height:auto;' +\n          'min-width:0!important;min-height:0!important;' +\n          'max-width:none!important;max-height:none!important;' +\n          'image-orientation:0deg!important;\">'\n        );\n      });\n    },\n\n    resetPreview: function () {\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n\n        $this.css({\n          width: data.width,\n          height: data.height\n        }).html(data.html).removeData(DATA_PREVIEW);\n      });\n    },\n\n    preview: function () {\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var cropBoxWidth = cropBox.width;\n      var cropBoxHeight = cropBox.height;\n      var width = image.width;\n      var height = image.height;\n      var left = cropBox.left - canvas.left - image.left;\n      var top = cropBox.top - canvas.top - image.top;\n\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      this.$clone2.css({\n        width: width,\n        height: height,\n        marginLeft: -left,\n        marginTop: -top,\n        transform: getTransform(image)\n      });\n\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n\n        $this.css({\n          width: newWidth,\n          height: newHeight\n        }).find('img').css({\n          width: width * ratio,\n          height: height * ratio,\n          marginLeft: -left * ratio,\n          marginTop: -top * ratio,\n          transform: getTransform(image)\n        });\n      });\n    },\n\n    bind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.on(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.on(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.on(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.on(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.on(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.on(EVENT_MOUSE_DOWN, $.proxy(this.cropStart, this));\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.on(EVENT_WHEEL, $.proxy(this.wheel, this));\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.on(EVENT_DBLCLICK, $.proxy(this.dblclick, this));\n      }\n\n      $document.\n        on(EVENT_MOUSE_MOVE, (this._cropMove = proxy(this.cropMove, this))).\n        on(EVENT_MOUSE_UP, (this._cropEnd = proxy(this.cropEnd, this)));\n\n      if (options.responsive) {\n        $window.on(EVENT_RESIZE, (this._resize = proxy(this.resize, this)));\n      }\n    },\n\n    unbind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.off(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.off(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.off(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.off(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.off(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.off(EVENT_MOUSE_DOWN, this.cropStart);\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.off(EVENT_WHEEL, this.wheel);\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.off(EVENT_DBLCLICK, this.dblclick);\n      }\n\n      $document.\n        off(EVENT_MOUSE_MOVE, this._cropMove).\n        off(EVENT_MOUSE_UP, this._cropEnd);\n\n      if (options.responsive) {\n        $window.off(EVENT_RESIZE, this._resize);\n      }\n    },\n\n    resize: function () {\n      var restore = this.options.restore;\n      var $container = this.$container;\n      var container = this.container;\n      var canvasData;\n      var cropBoxData;\n      var ratio;\n\n      // Check `container` is necessary for IE8\n      if (this.isDisabled || !container) {\n        return;\n      }\n\n      ratio = $container.width() / container.width;\n\n      // Resize when width changed or height changed\n      if (ratio !== 1 || $container.height() !== container.height) {\n        if (restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n\n        this.render();\n\n        if (restore) {\n          this.setCanvasData($.each(canvasData, function (i, n) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData($.each(cropBoxData, function (i, n) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n\n    dblclick: function () {\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (this.$dragBox.hasClass(CLASS_CROP)) {\n        this.setDragMode(ACTION_MOVE);\n      } else {\n        this.setDragMode(ACTION_CROP);\n      }\n    },\n\n    wheel: function (event) {\n      var e = event.originalEvent || event;\n      var ratio = num(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      event.preventDefault();\n\n      // Limit wheel speed to prevent zoom too fast\n      if (this.wheeling) {\n        return;\n      }\n\n      this.wheeling = true;\n\n      setTimeout($.proxy(function () {\n        this.wheeling = false;\n      }, this), 50);\n\n      if (e.deltaY) {\n        delta = e.deltaY > 0 ? 1 : -1;\n      } else if (e.wheelDelta) {\n        delta = -e.wheelDelta / 120;\n      } else if (e.detail) {\n        delta = e.detail > 0 ? 1 : -1;\n      }\n\n      this.zoom(-delta * ratio, event);\n    },\n\n    cropStart: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var touchesLength;\n      var action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.startX2 = e.pageX;\n            this.startY2 = e.pageY;\n            action = ACTION_ZOOM;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      action = action || $(e.target).data(DATA_ACTION);\n\n      if (REGEXP_ACTIONS.test(action)) {\n        if (this.trigger(EVENT_CROP_START, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.action = action;\n        this.cropping = false;\n\n        // IE8  has `event.pageX/Y`, but not `event.originalEvent.pageX/Y`\n        // IE10 has `event.originalEvent.pageX/Y`, but not `event.pageX/Y`\n        this.startX = e.pageX || originalEvent && originalEvent.pageX;\n        this.startY = e.pageY || originalEvent && originalEvent.pageY;\n\n        if (action === ACTION_CROP) {\n          this.cropping = true;\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      }\n    },\n\n    cropMove: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var action = this.action;\n      var touchesLength;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.endX2 = e.pageX;\n            this.endY2 = e.pageY;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      if (action) {\n        if (this.trigger(EVENT_CROP_MOVE, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.endX = e.pageX || originalEvent && originalEvent.pageX;\n        this.endY = e.pageY || originalEvent && originalEvent.pageY;\n\n        this.change(e.shiftKey, action === ACTION_ZOOM ? event : null);\n      }\n    },\n\n    cropEnd: function (event) {\n      var originalEvent = event.originalEvent;\n      var action = this.action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (action) {\n        event.preventDefault();\n\n        if (this.cropping) {\n          this.cropping = false;\n          this.$dragBox.toggleClass(CLASS_MODAL, this.isCropped && this.options.modal);\n        }\n\n        this.action = '';\n\n        this.trigger(EVENT_CROP_END, {\n          originalEvent: originalEvent,\n          action: action\n        });\n      }\n    },\n\n    change: function (shiftKey, event) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var action = this.action;\n      var container = this.container;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var width = cropBox.width;\n      var height = cropBox.height;\n      var left = cropBox.left;\n      var top = cropBox.top;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = container.width;\n      var maxHeight = container.height;\n      var renderable = true;\n      var offset;\n      var range;\n\n      // Locking aspect ratio in \"free mode\" by holding shift key (#259)\n      if (!aspectRatio && shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n\n      if (this.limited) {\n        minLeft = cropBox.minLeft;\n        minTop = cropBox.minTop;\n        maxWidth = minLeft + min(container.width, canvas.left + canvas.width);\n        maxHeight = minTop + min(container.height, canvas.top + canvas.height);\n      }\n\n      range = {\n        x: this.endX - this.startX,\n        y: this.endY - this.startY\n      };\n\n      if (aspectRatio) {\n        range.X = range.y * aspectRatio;\n        range.Y = range.x / aspectRatio;\n      }\n\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n\n        // Resize crop box\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top -= range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height -= range.y;\n          top += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width -= range.x;\n          left += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left -= range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += range.X;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        // Move canvas\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n\n        // Zoom canvas\n        case ACTION_ZOOM:\n          this.zoom((function (x1, y1, x2, y2) {\n            var z1 = sqrt(x1 * x1 + y1 * y1);\n            var z2 = sqrt(x2 * x2 + y2 * y2);\n\n            return (z2 - z1) / z1;\n          })(\n            abs(this.startX - this.startX2),\n            abs(this.startY - this.startY2),\n            abs(this.endX - this.endX2),\n            abs(this.endY - this.endY2)\n          ), event);\n          this.startX2 = this.endX2;\n          this.startY2 = this.endY2;\n          renderable = false;\n          break;\n\n        // Create crop box\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n\n          offset = this.$cropper.offset();\n          left = this.startX - offset.left;\n          top = this.startY - offset.top;\n          width = cropBox.minWidth;\n          height = cropBox.minHeight;\n\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n\n          if (range.y < 0) {\n            top -= height;\n          }\n\n          // Show the crop box if is hidden\n          if (!this.isCropped) {\n            this.$cropBox.removeClass(CLASS_HIDDEN);\n            this.isCropped = true;\n\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n\n          break;\n\n        // No default\n      }\n\n      if (renderable) {\n        cropBox.width = width;\n        cropBox.height = height;\n        cropBox.left = left;\n        cropBox.top = top;\n        this.action = action;\n\n        this.renderCropBox();\n      }\n\n      // Override\n      this.startX = this.endX;\n      this.startY = this.endY;\n    },\n\n    // Show the crop box manually\n    crop: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      if (!this.isCropped) {\n        this.isCropped = true;\n        this.limitCropBox(true, true);\n\n        if (this.options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n\n        this.$cropBox.removeClass(CLASS_HIDDEN);\n      }\n\n      this.setCropBoxData(this.initialCropBox);\n    },\n\n    // Reset the image and crop box to their initial states\n    reset: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      this.image = $.extend({}, this.initialImage);\n      this.canvas = $.extend({}, this.initialCanvas);\n      this.cropBox = $.extend({}, this.initialCropBox);\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    // Clear the crop box\n    clear: function () {\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      $.extend(this.cropBox, {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      });\n\n      this.isCropped = false;\n      this.renderCropBox();\n\n      this.limitCanvas(true, true);\n\n      // Render canvas after crop box rendered\n      this.renderCanvas();\n\n      this.$dragBox.removeClass(CLASS_MODAL);\n      this.$cropBox.addClass(CLASS_HIDDEN);\n    },\n\n    /**\n     * Replace the image's src and rebuild the cropper\n     *\n     * @param {String} url\n     * @param {Boolean} onlyColorChanged (optional)\n     */\n    replace: function (url, onlyColorChanged) {\n      if (!this.isDisabled && url) {\n        if (this.isImg) {\n          this.$element.attr('src', url);\n        }\n\n        if (onlyColorChanged) {\n          this.url = url;\n          this.$clone.attr('src', url);\n\n          if (this.isBuilt) {\n            this.$preview.find('img').add(this.$clone2).attr('src', url);\n          }\n        } else {\n          if (this.isImg) {\n            this.isReplaced = true;\n          }\n\n          // Clear previous data\n          this.options.data = null;\n          this.load(url);\n        }\n      }\n    },\n\n    // Enable (unfreeze) the cropper\n    enable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = false;\n        this.$cropper.removeClass(CLASS_DISABLED);\n      }\n    },\n\n    // Disable (freeze) the cropper\n    disable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = true;\n        this.$cropper.addClass(CLASS_DISABLED);\n      }\n    },\n\n    // Destroy the cropper and remove the instance from the image\n    destroy: function () {\n      var $this = this.$element;\n\n      if (this.isLoaded) {\n        if (this.isImg && this.isReplaced) {\n          $this.attr('src', this.originalUrl);\n        }\n\n        this.unbuild();\n        $this.removeClass(CLASS_HIDDEN);\n      } else {\n        if (this.isImg) {\n          $this.off(EVENT_LOAD, this.start);\n        } else if (this.$clone) {\n          this.$clone.remove();\n        }\n      }\n\n      $this.removeData(NAMESPACE);\n    },\n\n    /**\n     * Move the canvas with relative offsets\n     *\n     * @param {Number} offsetX\n     * @param {Number} offsetY (optional)\n     */\n    move: function (offsetX, offsetY) {\n      var canvas = this.canvas;\n\n      this.moveTo(\n        isUndefined(offsetX) ? offsetX : canvas.left + num(offsetX),\n        isUndefined(offsetY) ? offsetY : canvas.top + num(offsetY)\n      );\n    },\n\n    /**\n     * Move the canvas to an absolute point\n     *\n     * @param {Number} x\n     * @param {Number} y (optional)\n     */\n    moveTo: function (x, y) {\n      var canvas = this.canvas;\n      var isChanged = false;\n\n      // If \"y\" is not present, its default value is \"x\"\n      if (isUndefined(y)) {\n        y = x;\n      }\n\n      x = num(x);\n      y = num(y);\n\n      if (this.isBuilt && !this.isDisabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvas.left = x;\n          isChanged = true;\n        }\n\n        if (isNumber(y)) {\n          canvas.top = y;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderCanvas(true);\n        }\n      }\n    },\n\n    /**\n     * Zoom the canvas with a relative ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoom: function (ratio, _event) {\n      var canvas = this.canvas;\n\n      ratio = num(ratio);\n\n      if (ratio < 0) {\n        ratio =  1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n\n      this.zoomTo(canvas.width * ratio / canvas.naturalWidth, _event);\n    },\n\n    /**\n     * Zoom the canvas to an absolute ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoomTo: function (ratio, _event) {\n      var options = this.options;\n      var canvas = this.canvas;\n      var width = canvas.width;\n      var height = canvas.height;\n      var naturalWidth = canvas.naturalWidth;\n      var naturalHeight = canvas.naturalHeight;\n      var originalEvent;\n      var newWidth;\n      var newHeight;\n      var offset;\n      var center;\n\n      ratio = num(ratio);\n\n      if (ratio >= 0 && this.isBuilt && !this.isDisabled && options.zoomable) {\n        newWidth = naturalWidth * ratio;\n        newHeight = naturalHeight * ratio;\n\n        if (_event) {\n          originalEvent = _event.originalEvent;\n        }\n\n        if (this.trigger(EVENT_ZOOM, {\n          originalEvent: originalEvent,\n          oldRatio: width / naturalWidth,\n          ratio: newWidth / naturalWidth\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        if (originalEvent) {\n          offset = this.$cropper.offset();\n          center = originalEvent.touches ? getTouchesCenter(originalEvent.touches) : {\n            pageX: _event.pageX || originalEvent.pageX || 0,\n            pageY: _event.pageY || originalEvent.pageY || 0\n          };\n\n          // Zoom from the triggering point of the event\n          canvas.left -= (newWidth - width) * (\n            ((center.pageX - offset.left) - canvas.left) / width\n          );\n          canvas.top -= (newHeight - height) * (\n            ((center.pageY - offset.top) - canvas.top) / height\n          );\n        } else {\n\n          // Zoom from the center of the canvas\n          canvas.left -= (newWidth - width) / 2;\n          canvas.top -= (newHeight - height) / 2;\n        }\n\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Rotate the canvas with a relative degree\n     *\n     * @param {Number} degree\n     */\n    rotate: function (degree) {\n      this.rotateTo((this.image.rotate || 0) + num(degree));\n    },\n\n    /**\n     * Rotate the canvas to an absolute degree\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()\n     *\n     * @param {Number} degree\n     */\n    rotateTo: function (degree) {\n      degree = num(degree);\n\n      if (isNumber(degree) && this.isBuilt && !this.isDisabled && this.options.rotatable) {\n        this.image.rotate = degree % 360;\n        this.isRotated = true;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Scale the image\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()\n     *\n     * @param {Number} scaleX\n     * @param {Number} scaleY (optional)\n     */\n    scale: function (scaleX, scaleY) {\n      var image = this.image;\n      var isChanged = false;\n\n      // If \"scaleY\" is not present, its default value is \"scaleX\"\n      if (isUndefined(scaleY)) {\n        scaleY = scaleX;\n      }\n\n      scaleX = num(scaleX);\n      scaleY = num(scaleY);\n\n      if (this.isBuilt && !this.isDisabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          image.scaleX = scaleX;\n          isChanged = true;\n        }\n\n        if (isNumber(scaleY)) {\n          image.scaleY = scaleY;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderImage(true);\n        }\n      }\n    },\n\n    /**\n     * Scale the abscissa of the image\n     *\n     * @param {Number} scaleX\n     */\n    scaleX: function (scaleX) {\n      var scaleY = this.image.scaleY;\n\n      this.scale(scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n\n    /**\n     * Scale the ordinate of the image\n     *\n     * @param {Number} scaleY\n     */\n    scaleY: function (scaleY) {\n      var scaleX = this.image.scaleX;\n\n      this.scale(isNumber(scaleX) ? scaleX : 1, scaleY);\n    },\n\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     *\n     * @param {Boolean} isRounded (optional)\n     * @return {Object} data\n     */\n    getData: function (isRounded) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var ratio;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          x: cropBox.left - canvas.left,\n          y: cropBox.top - canvas.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n\n        ratio = image.width / image.naturalWidth;\n\n        $.each(data, function (i, n) {\n          n = n / ratio;\n          data[i] = isRounded ? round(n) : n;\n        });\n\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (options.rotatable) {\n        data.rotate = image.rotate || 0;\n      }\n\n      if (options.scalable) {\n        data.scaleX = image.scaleX || 1;\n        data.scaleY = image.scaleY || 1;\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the cropped area position and size with new data\n     *\n     * @param {Object} data\n     */\n    setData: function (data) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBoxData = {};\n      var isRotated;\n      var isScaled;\n      var ratio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== image.rotate) {\n            image.rotate = data.rotate;\n            this.isRotated = isRotated = true;\n          }\n        }\n\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== image.scaleX) {\n            image.scaleX = data.scaleX;\n            isScaled = true;\n          }\n\n          if (isNumber(data.scaleY) && data.scaleY !== image.scaleY) {\n            image.scaleY = data.scaleY;\n            isScaled = true;\n          }\n        }\n\n        if (isRotated) {\n          this.renderCanvas();\n        } else if (isScaled) {\n          this.renderImage();\n        }\n\n        ratio = image.width / image.naturalWidth;\n\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvas.left;\n        }\n\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvas.top;\n        }\n\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n\n        this.setCropBoxData(cropBoxData);\n      }\n    },\n\n    /**\n     * Get the container size data\n     *\n     * @return {Object} data\n     */\n    getContainerData: function () {\n      return this.isBuilt ? this.container : {};\n    },\n\n    /**\n     * Get the image position and size data\n     *\n     * @return {Object} data\n     */\n    getImageData: function () {\n      return this.isLoaded ? this.image : {};\n    },\n\n    /**\n     * Get the canvas position and size data\n     *\n     * @return {Object} data\n     */\n    getCanvasData: function () {\n      var canvas = this.canvas;\n      var data = {};\n\n      if (this.isBuilt) {\n        $.each([\n          'left',\n          'top',\n          'width',\n          'height',\n          'naturalWidth',\n          'naturalHeight'\n        ], function (i, n) {\n          data[n] = canvas[n];\n        });\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the canvas position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCanvasData: function (data) {\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvas.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          canvas.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          canvas.width = data.width;\n          canvas.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvas.height = data.height;\n          canvas.width = data.height * aspectRatio;\n        }\n\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Get the crop box position and size data\n     *\n     * @return {Object} data\n     */\n    getCropBoxData: function () {\n      var cropBox = this.cropBox;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          left: cropBox.left,\n          top: cropBox.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n      }\n\n      return data || {};\n    },\n\n    /**\n     * Set the crop box position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCropBoxData: function (data) {\n      var cropBox = this.cropBox;\n      var aspectRatio = this.options.aspectRatio;\n      var isWidthChanged;\n      var isHeightChanged;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && this.isCropped && !this.isDisabled && $.isPlainObject(data)) {\n\n        if (isNumber(data.left)) {\n          cropBox.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          cropBox.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          isWidthChanged = true;\n          cropBox.width = data.width;\n        }\n\n        if (isNumber(data.height)) {\n          isHeightChanged = true;\n          cropBox.height = data.height;\n        }\n\n        if (aspectRatio) {\n          if (isWidthChanged) {\n            cropBox.height = cropBox.width / aspectRatio;\n          } else if (isHeightChanged) {\n            cropBox.width = cropBox.height * aspectRatio;\n          }\n        }\n\n        this.renderCropBox();\n      }\n    },\n\n    /**\n     * Get a canvas drawn the cropped image\n     *\n     * @param {Object} options (optional)\n     * @return {HTMLCanvasElement} canvas\n     */\n    getCroppedCanvas: function (options) {\n      var originalWidth;\n      var originalHeight;\n      var canvasWidth;\n      var canvasHeight;\n      var scaledWidth;\n      var scaledHeight;\n      var scaledRatio;\n      var aspectRatio;\n      var canvas;\n      var context;\n      var data;\n\n      if (!this.isBuilt || !this.isCropped || !SUPPORT_CANVAS) {\n        return;\n      }\n\n      if (!$.isPlainObject(options)) {\n        options = {};\n      }\n\n      data = this.getData();\n      originalWidth = data.width;\n      originalHeight = data.height;\n      aspectRatio = originalWidth / originalHeight;\n\n      if ($.isPlainObject(options)) {\n        scaledWidth = options.width;\n        scaledHeight = options.height;\n\n        if (scaledWidth) {\n          scaledHeight = scaledWidth / aspectRatio;\n          scaledRatio = scaledWidth / originalWidth;\n        } else if (scaledHeight) {\n          scaledWidth = scaledHeight * aspectRatio;\n          scaledRatio = scaledHeight / originalHeight;\n        }\n      }\n\n      // The canvas element will use `Math.floor` on a float number, so floor first\n      canvasWidth = floor(scaledWidth || originalWidth);\n      canvasHeight = floor(scaledHeight || originalHeight);\n\n      canvas = $('<canvas>')[0];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      context = canvas.getContext('2d');\n\n      if (options.fillColor) {\n        context.fillStyle = options.fillColor;\n        context.fillRect(0, 0, canvasWidth, canvasHeight);\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n      context.drawImage.apply(context, (function () {\n        var source = getSourceCanvas(this.$clone[0], this.image);\n        var sourceWidth = source.width;\n        var sourceHeight = source.height;\n        var canvas = this.canvas;\n        var params = [source];\n\n        // Source canvas\n        var srcX = data.x + canvas.naturalWidth * (abs(data.scaleX || 1) - 1) / 2;\n        var srcY = data.y + canvas.naturalHeight * (abs(data.scaleY || 1) - 1) / 2;\n        var srcWidth;\n        var srcHeight;\n\n        // Destination canvas\n        var dstX;\n        var dstY;\n        var dstWidth;\n        var dstHeight;\n\n        if (srcX <= -originalWidth || srcX > sourceWidth) {\n          srcX = srcWidth = dstX = dstWidth = 0;\n        } else if (srcX <= 0) {\n          dstX = -srcX;\n          srcX = 0;\n          srcWidth = dstWidth = min(sourceWidth, originalWidth + srcX);\n        } else if (srcX <= sourceWidth) {\n          dstX = 0;\n          srcWidth = dstWidth = min(originalWidth, sourceWidth - srcX);\n        }\n\n        if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {\n          srcY = srcHeight = dstY = dstHeight = 0;\n        } else if (srcY <= 0) {\n          dstY = -srcY;\n          srcY = 0;\n          srcHeight = dstHeight = min(sourceHeight, originalHeight + srcY);\n        } else if (srcY <= sourceHeight) {\n          dstY = 0;\n          srcHeight = dstHeight = min(originalHeight, sourceHeight - srcY);\n        }\n\n        // All the numerical parameters should be integer for `drawImage` (#476)\n        params.push(floor(srcX), floor(srcY), floor(srcWidth), floor(srcHeight));\n\n        // Scale destination sizes\n        if (scaledRatio) {\n          dstX *= scaledRatio;\n          dstY *= scaledRatio;\n          dstWidth *= scaledRatio;\n          dstHeight *= scaledRatio;\n        }\n\n        // Avoid \"IndexSizeError\" in IE and Firefox\n        if (dstWidth > 0 && dstHeight > 0) {\n          params.push(floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n        }\n\n        return params;\n      }).call(this));\n\n      return canvas;\n    },\n\n    /**\n     * Change the aspect ratio of the crop box\n     *\n     * @param {Number} aspectRatio\n     */\n    setAspectRatio: function (aspectRatio) {\n      var options = this.options;\n\n      if (!this.isDisabled && !isUndefined(aspectRatio)) {\n\n        // 0 -> NaN\n        options.aspectRatio = max(0, aspectRatio) || NaN;\n\n        if (this.isBuilt) {\n          this.initCropBox();\n\n          if (this.isCropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n    },\n\n    /**\n     * Change the drag mode\n     *\n     * @param {String} mode (optional)\n     */\n    setDragMode: function (mode) {\n      var options = this.options;\n      var croppable;\n      var movable;\n\n      if (this.isLoaded && !this.isDisabled) {\n        croppable = mode === ACTION_CROP;\n        movable = options.movable && mode === ACTION_MOVE;\n        mode = (croppable || movable) ? mode : ACTION_NONE;\n\n        this.$dragBox.\n          data(DATA_ACTION, mode).\n          toggleClass(CLASS_CROP, croppable).\n          toggleClass(CLASS_MOVE, movable);\n\n        if (!options.cropBoxMovable) {\n\n          // Sync drag mode to crop box when it is not movable(#300)\n          this.$face.\n            data(DATA_ACTION, mode).\n            toggleClass(CLASS_CROP, croppable).\n            toggleClass(CLASS_MOVE, movable);\n        }\n      }\n    }\n  };\n\n  Cropper.DEFAULTS = {\n\n    // Define the view mode of the cropper\n    viewMode: 0, // 0, 1, 2, 3\n\n    // Define the dragging mode of the cropper\n    dragMode: 'crop', // 'crop', 'move' or 'none'\n\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n\n    // An object with the previous cropping result data\n    data: null,\n\n    // A jQuery selector for adding extra containers to preview\n    preview: '',\n\n    // Re-render the cropper when resize the window\n    responsive: true,\n\n    // Restore the cropped area after resize the window\n    restore: true,\n\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n\n    // Show the black modal\n    modal: true,\n\n    // Show the dashed lines for guiding\n    guides: true,\n\n    // Show the center indicator for guiding\n    center: true,\n\n    // Show the white modal to highlight the crop box\n    highlight: true,\n\n    // Show the grid background\n    background: true,\n\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n\n    // Enable to move the image\n    movable: true,\n\n    // Enable to rotate the image\n    rotatable: true,\n\n    // Enable to scale the image\n    scalable: true,\n\n    // Enable to zoom the image\n    zoomable: true,\n\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n\n    // Enable to move the crop box\n    cropBoxMovable: true,\n\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: 200,\n    minContainerHeight: 100,\n\n    // Shortcuts of events\n    build: null,\n    built: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n\n  Cropper.setDefaults = function (options) {\n    $.extend(Cropper.DEFAULTS, options);\n  };\n\n  Cropper.TEMPLATE = (\n    '<div class=\"cropper-container\">' +\n      '<div class=\"cropper-wrap-box\">' +\n        '<div class=\"cropper-canvas\"></div>' +\n      '</div>' +\n      '<div class=\"cropper-drag-box\"></div>' +\n      '<div class=\"cropper-crop-box\">' +\n        '<span class=\"cropper-view-box\"></span>' +\n        '<span class=\"cropper-dashed dashed-h\"></span>' +\n        '<span class=\"cropper-dashed dashed-v\"></span>' +\n        '<span class=\"cropper-center\"></span>' +\n        '<span class=\"cropper-face\"></span>' +\n        '<span class=\"cropper-line line-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-line line-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-line line-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-line line-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-point point-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-point point-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-point point-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-ne\" data-action=\"ne\"></span>' +\n        '<span class=\"cropper-point point-nw\" data-action=\"nw\"></span>' +\n        '<span class=\"cropper-point point-sw\" data-action=\"sw\"></span>' +\n        '<span class=\"cropper-point point-se\" data-action=\"se\"></span>' +\n      '</div>' +\n    '</div>'\n  );\n\n  // Save the other cropper\n  Cropper.other = $.fn.cropper;\n\n  // Register as jQuery plugin\n  $.fn.cropper = function (option) {\n    var args = toArray(arguments, 1);\n    var result;\n\n    this.each(function () {\n      var $this = $(this);\n      var data = $this.data(NAMESPACE);\n      var options;\n      var fn;\n\n      if (!data) {\n        if (/destroy/.test(option)) {\n          return;\n        }\n\n        options = $.extend({}, $this.data(), $.isPlainObject(option) && option);\n        $this.data(NAMESPACE, (data = new Cropper(this, options)));\n      }\n\n      if (typeof option === 'string' && $.isFunction(fn = data[option])) {\n        result = fn.apply(data, args);\n      }\n    });\n\n    return isUndefined(result) ? this : result;\n  };\n\n  $.fn.cropper.Constructor = Cropper;\n  $.fn.cropper.setDefaults = Cropper.setDefaults;\n\n  // No conflict\n  $.fn.cropper.noConflict = function () {\n    $.fn.cropper = Cropper.other;\n    return this;\n  };\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /var/cache/omnibus/src/gitlab-rails/vendor/assets/javascripts/cropper.js\n// module id = aX1M\n// module chunks = 14","/* eslint-disable comma-dangle, no-unused-vars, class-methods-use-this, quotes, consistent-return, func-names, prefer-arrow-callback, space-before-function-paren, max-len */\n/* global Flash */\n\n((global) => {\n  class Profile {\n    constructor({ form } = {}) {\n      this.onSubmitForm = this.onSubmitForm.bind(this);\n      this.form = form || $('.edit-user');\n      this.bindEvents();\n      this.initAvatarGlCrop();\n    }\n\n    initAvatarGlCrop() {\n      const cropOpts = {\n        filename: '.js-avatar-filename',\n        previewImage: '.avatar-image .avatar',\n        modalCrop: '.modal-profile-crop',\n        pickImageEl: '.js-choose-user-avatar-button',\n        uploadImageBtn: '.js-upload-user-avatar',\n        modalCropImg: '.modal-profile-crop-image'\n      };\n      this.avatarGlCrop = $('.js-user-avatar-input').glCrop(cropOpts).data('glcrop');\n    }\n\n    bindEvents() {\n      $('.js-preferences-form').on('change.preference', 'input[type=radio]', this.submitForm);\n      $('#user_notification_email').on('change', this.submitForm);\n      $('.update-username').on('ajax:before', this.beforeUpdateUsername);\n      $('.update-username').on('ajax:complete', this.afterUpdateUsername);\n      $('.update-notifications').on('ajax:success', this.onUpdateNotifs);\n      this.form.on('submit', this.onSubmitForm);\n    }\n\n    submitForm() {\n      return $(this).parents('form').submit();\n    }\n\n    onSubmitForm(e) {\n      e.preventDefault();\n      return this.saveForm();\n    }\n\n    beforeUpdateUsername() {\n      $('.loading-username', this).removeClass('hidden');\n    }\n\n    afterUpdateUsername() {\n      $('.loading-username', this).addClass('hidden');\n      $('button[type=submit]', this).enable();\n    }\n\n    onUpdateNotifs(e, data) {\n      return data.saved ?\n        new Flash(\"Notification settings saved\", \"notice\") :\n        new Flash(\"Failed to save new settings\", \"alert\");\n    }\n\n    saveForm() {\n      const self = this;\n      const formData = new FormData(this.form[0]);\n      const avatarBlob = this.avatarGlCrop.getBlob();\n\n      if (avatarBlob != null) {\n        formData.append('user[avatar]', avatarBlob, 'avatar.png');\n      }\n\n      return $.ajax({\n        url: this.form.attr('action'),\n        type: this.form.attr('method'),\n        data: formData,\n        dataType: \"json\",\n        processData: false,\n        contentType: false,\n        success: response => new Flash(response.message, 'notice'),\n        error: jqXHR => new Flash(jqXHR.responseJSON.message, 'alert'),\n        complete: () => {\n          window.scrollTo(0, 0);\n          // Enable submit button after requests ends\n          return self.form.find(':input[disabled]').enable();\n        }\n      });\n    }\n  }\n\n  $(function() {\n    $(document).on('input.ssh_key', '#key_key', function() {\n      const $title = $('#key_title');\n      const comment = $(this).val().match(/^\\S+ \\S+ (.+)\\n?$/);\n\n      // Extract the SSH Key title from its comment\n      if (comment && comment.length > 1) {\n        return $title.val(comment[1]).change();\n      }\n    });\n    if (global.utils.getPagePath() === 'profiles') {\n      return new Profile();\n    }\n  });\n})(window.gl || (window.gl = {}));\n\n\n\n// WEBPACK FOOTER //\n// ./profile/profile.js"],"sourceRoot":""}